<!DOCTYPE html>


<html lang="zh-CN">


<head>
  <meta charset="utf-8" />
    
  <meta name="description" content="我是一位牧码人，快放码过来，" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     D4C的世界
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

<link rel="alternate" href="/atom.xml" title="D4C的世界" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://gitee.com/dancer4code"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">D4C的世界</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-logging/logging日志-log4j、log4j-2、logback、commons-logging和slf4j的区别联系以及简单用法"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/08/logging/logging%E6%97%A5%E5%BF%97-log4j%E3%80%81log4j-2%E3%80%81logback%E3%80%81commons-logging%E5%92%8Cslf4j%E7%9A%84%E5%8C%BA%E5%88%AB%E8%81%94%E7%B3%BB%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"
    >logging日志-log4j、log4j-2、logback、commons-logging和slf4j的区别联系以及简单用法</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/08/logging/logging%E6%97%A5%E5%BF%97-log4j%E3%80%81log4j-2%E3%80%81logback%E3%80%81commons-logging%E5%92%8Cslf4j%E7%9A%84%E5%8C%BA%E5%88%AB%E8%81%94%E7%B3%BB%E4%BB%A5%E5%8F%8A%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/" class="article-date">
  <time datetime="2020-07-08T14:36:00.000Z" itemprop="datePublished">2020-07-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%97%A5%E5%BF%97/">日志</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h1><ul>
<li><p><em>commons-logging:</em> Apache基金会所属最早提供的日志的门面接口。之前叫Jakarta Commons Logging，后更名为Commons Logging.避免和具体的日志方案直接耦合。类似于JDBC 的api 接口，具体的的JDBC driver 实现由各数据库提供商实现。通过统一接口解耦，不过其内部也实现了一些简单日志方案。</p>
</li>
<li><p><em>Slf4j:</em> 全称为Simple Logging Facade for JAVA：java简单日志门面。 是对不同日志框架提供的一个门面封装。可以在部署的时候不修改任何配置即可接入一种日志实现方案。和commons-loging 应该有一样的初衷。设计上更好一些，没有commons 那么多潜规则。</p>
</li>
<li><p> <em>Jul:</em>  (Java Util Logging)自Java1.4以来的官方日志实现。可参考这里<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a072c2c5ac0a">使用步骤</a></p>
</li>
</ul>
<ul>
<li><p><em>Log4j:</em>  Apache Log4j是一个基于Java的日志记录工具。它是由Ceki Gülcü首创的，现在则是Apache软件基金会的一个项目。 Log4j是几种Java日志框架之一。</p>
</li>
<li><p>*Logback:*一套日志组件的实现(Slf4j阵营)。</p>
</li>
<li><p> <em>Log4j 2:</em> Apache Log4j 2是apache开发的一款Log4j的升级产品。log4j属于1.x.x, log4j 2属于2.x.x.   <a target="_blank" rel="noopener" href="http://logging.apache.org/log4j/2.x/">Apache官网地址</a> | <a target="_blank" rel="noopener" href="https://github.com/apache/logging-log4j2">github地址</a></p>
</li>
</ul>
<ul>
<li><ul>
<li> <strong><em>log4j优点</em></strong></li>
<li>能支持多个参数，并通过{} 占位符进行替换，避免老写logger.isXXXEnabled 这种无奈的判断，带来性能提升</li>
<li>OSGI 机制更好兼容支持</li>
</ul>
</li>
</ul>
<p>$\color{red}{总结粗略可以看成：} $<br><em>日志接口：</em> commons-logging、Slf4j<br><em>日志实现：</em> log4j、logback、log4j2</p>
<p> 推荐使用slf4j+X(log4j/logback/log4j 2)这种方式,而不是直接使用log4j/logback/log4j 2。具体原因可参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ec508c929c61">为什么要用 SLF4J</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/19382524-a1821ba7ca2f3a6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="slf4j日志相关.png"></p>
<hr>
<h1 id="2-简单用法-测试环境针对java，web环境没测"><a href="#2-简单用法-测试环境针对java，web环境没测" class="headerlink" title="2. 简单用法(测试环境针对java，web环境没测)"></a>2. 简单用法(测试环境针对java，web环境没测)</h1><h2 id="2-1-slf4j-log4j"><a href="#2-1-slf4j-log4j" class="headerlink" title="2.1 slf4j+log4j"></a>2.1 slf4j+log4j</h2><p><em>maven依赖</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;slf4j-log4j12&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;1.7.26&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p><em>配置文件位置classpath下名称 log4j.properties</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger&#x3D;ALL, Console ,File </span><br><span class="line"></span><br><span class="line">#Console</span><br><span class="line">log4j.appender.Console&#x3D;org.apache.log4j.ConsoleAppender </span><br><span class="line">log4j.appender.Console.layout&#x3D;org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.Console.layout.ConversionPattern&#x3D;%d [%t] %-5p [%c] - %m%n</span><br><span class="line"></span><br><span class="line">#File</span><br><span class="line">log4j.appender.File &#x3D; org.apache.log4j.FileAppender</span><br><span class="line">log4j.appender.File.File &#x3D; D:&#x2F;&#x2F;log4j2.log</span><br><span class="line">log4j.appender.File.layout &#x3D; org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.File.layout.ConversionPattern &#x3D;%d [%t] %-5p [%c] - %m%n</span><br></pre></td></tr></table></figure>
<p><em>代码测试</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.dancer4code.slf4j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * User: liangqing.zhao(zlq)</span><br><span class="line"> * Date: 2019&#x2F;9&#x2F;21 13:24</span><br><span class="line"> * Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class Slf4jTest &#123;</span><br><span class="line">    static Logger log &#x3D; LoggerFactory.getLogger(Slf4jTest.class);</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        log.trace(&quot;hello trace&quot;);</span><br><span class="line">        log.debug(&quot;hello debug&quot;);</span><br><span class="line">        log.info(&quot;hello info&quot;);</span><br><span class="line">        log.warn(&quot;hello warn&quot;);</span><br><span class="line">        log.error(&quot;hello error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>输出结果</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-09-21 22:03:14,581 [main] TRACE [com.dancer4code.slf4j.Slf4jTest] - hello trace</span><br><span class="line">2019-09-21 22:03:14,582 [main] DEBUG [com.dancer4code.slf4j.Slf4jTest] - hello debug</span><br><span class="line">2019-09-21 22:03:14,582 [main] INFO  [com.dancer4code.slf4j.Slf4jTest] - hello info</span><br><span class="line">2019-09-21 22:03:14,582 [main] WARN  [com.dancer4code.slf4j.Slf4jTest] - hello warn</span><br><span class="line">2019-09-21 22:03:14,582 [main] ERROR [com.dancer4code.slf4j.Slf4jTest] - hello error</span><br></pre></td></tr></table></figure>

<h2 id="2-2-slf4j-logback"><a href="#2-2-slf4j-logback" class="headerlink" title="2.2 slf4j+logback"></a>2.2 slf4j+logback</h2><p><em>maven依赖</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;logback-classic&lt;&#x2F;artifactId&gt;</span><br><span class="line">       &lt;version&gt;1.2.3&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><em>配置文件classpath下 logback.xml</em><br>完全来自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/696444e1a352">slf4j+logback的配置及使用</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!--scan:</span><br><span class="line">            当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</span><br><span class="line">scanPeriod:</span><br><span class="line">            设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</span><br><span class="line">debug:</span><br><span class="line">            当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</span><br><span class="line"></span><br><span class="line">configuration 子节点为 appender、logger、root</span><br><span class="line"></span><br><span class="line">            --&gt;</span><br><span class="line">&lt;configuration scan&#x3D;&quot;true&quot; scanPeriod&#x3D;&quot;60 seconds&quot; debug&#x3D;&quot;false&quot;&gt;</span><br><span class="line">    &lt;!--用于区分不同应用程序的记录--&gt;</span><br><span class="line">    &lt;contextName&gt;edu-cloud&lt;&#x2F;contextName&gt;</span><br><span class="line">    &lt;!--日志文件所在目录，如果是tomcat，如下写法日志文件会在则为$&#123;TOMCAT_HOME&#125;&#x2F;bin&#x2F;logs&#x2F;目录下--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;LOG_HOME&quot; value&#x3D;&quot;logs&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--控制台--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;stdout&quot; class&#x3D;&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger输出日志的logger名 %msg：日志消息，%n是换行符 --&gt;</span><br><span class="line">            &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level %logger&#123;36&#125; : %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">            &lt;!--解决乱码问题--&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--滚动文件--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;infoFile&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!-- ThresholdFilter:临界值过滤器，过滤掉 TRACE 和 DEBUG 级别的日志 --&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;INFO&lt;&#x2F;level&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;&#x2F;log.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;30&lt;&#x2F;maxHistory&gt;&lt;!--保存最近30天的日志--&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;</span><br><span class="line">            &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level %logger&#123;36&#125; : %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--滚动文件--&gt;</span><br><span class="line">    &lt;appender name&#x3D;&quot;errorFile&quot; class&#x3D;&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;</span><br><span class="line">        &lt;!-- ThresholdFilter:临界值过滤器，过滤掉 TRACE 和 DEBUG 级别的日志 --&gt;</span><br><span class="line">        &lt;filter class&#x3D;&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;</span><br><span class="line">            &lt;level&gt;error&lt;&#x2F;level&gt;</span><br><span class="line">        &lt;&#x2F;filter&gt;</span><br><span class="line">        &lt;rollingPolicy class&#x3D;&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;</span><br><span class="line">            &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;&#x2F;error.%d&#123;yyyy-MM-dd&#125;.log&lt;&#x2F;fileNamePattern&gt;</span><br><span class="line">            &lt;maxHistory&gt;30&lt;&#x2F;maxHistory&gt;&lt;!--保存最近30天的日志--&gt;</span><br><span class="line">        &lt;&#x2F;rollingPolicy&gt;</span><br><span class="line">        &lt;encoder&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;</span><br><span class="line">            &lt;pattern&gt;[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] %-5level %logger&#123;36&#125; : %msg%n&lt;&#x2F;pattern&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--将日志输出到logstack--&gt;</span><br><span class="line">    &lt;!--&lt;appender name&#x3D;&quot;logstash&quot; class&#x3D;&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;</span><br><span class="line">        &lt;destination&gt;47.93.173.81:7002&lt;&#x2F;destination&gt;</span><br><span class="line">        &lt;encoder class&#x3D;&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&gt;</span><br><span class="line">            &lt;charset&gt;UTF-8&lt;&#x2F;charset&gt;</span><br><span class="line">        &lt;&#x2F;encoder&gt;</span><br><span class="line">        &lt;keepAliveDuration&gt;5 minutes&lt;&#x2F;keepAliveDuration&gt;</span><br><span class="line">    &lt;&#x2F;appender&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--这里如果是info，spring、mybatis等框架则不会输出：TRACE &lt; DEBUG &lt; INFO &lt;  WARN &lt; ERROR--&gt;</span><br><span class="line">    &lt;!--root是所有logger的祖先，均继承root，如果某一个自定义的logger没有指定level，就会寻找</span><br><span class="line">    父logger看有没有指定级别，直到找到root。--&gt;</span><br><span class="line">    &lt;root level&#x3D;&quot;debug&quot;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;stdout&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;infoFile&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;errorFile&quot;&#x2F;&gt;</span><br><span class="line">        &lt;appender-ref ref&#x3D;&quot;logstash&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--为某个包单独配置logger</span><br><span class="line"></span><br><span class="line">    比如定时任务，写代码的包名为：com.seentao.task</span><br><span class="line">    步骤如下：</span><br><span class="line">    1、定义一个appender，取名为task（随意，只要下面logger引用就行了）</span><br><span class="line">    appender的配置按照需要即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    2、定义一个logger:</span><br><span class="line">    &lt;logger name&#x3D;&quot;com.seentao.task&quot; level&#x3D;&quot;DEBUG&quot; additivity&#x3D;&quot;false&quot;&gt;</span><br><span class="line">      &lt;appender-ref ref&#x3D;&quot;task&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;logger&gt;</span><br><span class="line">    注意：additivity必须设置为false，这样只会交给task这个appender，否则其他appender也会打印com.seentao.task里的log信息。</span><br><span class="line"></span><br><span class="line">    3、这样，在com.seentao.task的logger就会是上面定义的logger了。</span><br><span class="line">    private static Logger logger &#x3D; LoggerFactory.getLogger(Class1.class);</span><br><span class="line">    --&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>

<p><em>测试代码与上同</em></p>
<p><em>打印信息省略许多logback内部信息</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[2019-09-21 22:29:34.941] [main] DEBUG com.dancer4code.slf4j.Slf4jTest : hello debug</span><br><span class="line">[2019-09-21 22:29:34.943] [main] INFO  com.dancer4code.slf4j.Slf4jTest : hello info</span><br><span class="line">[2019-09-21 22:29:34.944] [main] WARN  com.dancer4code.slf4j.Slf4jTest : hello warn</span><br><span class="line">[2019-09-21 22:29:34.945] [main] ERROR com.dancer4code.slf4j.Slf4jTest : hello error</span><br></pre></td></tr></table></figure>
<p><em>参考了</em><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/taiyonghai/p/9290641.html">IDEA项目搭建十——使用slf4j和logback进行日志记录</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/696444e1a352">slf4j+logback的配置及使用</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38428623/article/details/82080509">Slf4j日志配置文件 logback.xml</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/duguxiaobiao/article/details/78988409">日志：slf4j+logback 的配置与使用</a><br><strong><code>谢谢你们(*V*)</code></strong></p>
<h2 id="2-3-slf4j-log4j-2"><a href="#2-3-slf4j-log4j-2" class="headerlink" title="2.3 slf4j+log4j 2"></a>2.3 slf4j+log4j 2</h2><p>(性能优越，不过集成一些流行框架后需要更改有点多。用不用结合自己的项目考虑)<br>请参考<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/2014/08/apache-log4j2/">Apache Log4j 2.0 值得升级吗</a></p>
<p><em>maven依赖</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.logging.log4j&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;log4j-slf4j-impl&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;2.9.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p><em>配置文件classpath下log4j2.xml</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span><br><span class="line">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span><br><span class="line">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span><br><span class="line">&lt;configuration status&#x3D;&quot;ERROR&quot; monitorInterval&#x3D;&quot;30&quot;&gt;</span><br><span class="line">    &lt;!--先定义所有的appender--&gt;</span><br><span class="line">    &lt;appenders&gt;</span><br><span class="line">        &lt;!--这个输出控制台的配置--&gt;</span><br><span class="line">        &lt;console name&#x3D;&quot;Console&quot; target&#x3D;&quot;SYSTEM_OUT&quot;&gt;</span><br><span class="line">            &lt;!--输出日志的格式--&gt;</span><br><span class="line">            &lt;PatternLayout pattern&#x3D;&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%5p] - %l - %m%n&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;console&gt;</span><br><span class="line">        &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;</span><br><span class="line">        &lt;File name&#x3D;&quot;log&quot; fileName&#x3D;&quot;log&#x2F;test.log&quot; append&#x3D;&quot;false&quot;&gt;</span><br><span class="line">            &lt;PatternLayout pattern&#x3D;&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;File&gt;</span><br><span class="line">        &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span><br><span class="line">        &lt;RollingFile name&#x3D;&quot;RollingFileInfo&quot; fileName&#x3D;&quot;$&#123;sys:user.home&#125;&#x2F;logs&#x2F;info.log&quot;</span><br><span class="line">                     filePattern&#x3D;&quot;$&#123;sys:user.home&#125;&#x2F;logs&#x2F;$$&#123;date:yyyy-MM&#125;&#x2F;info-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;</span><br><span class="line">            &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span><br><span class="line">            &lt;ThresholdFilter level&#x3D;&quot;info&quot; onMatch&#x3D;&quot;ACCEPT&quot; onMismatch&#x3D;&quot;DENY&quot;&#x2F;&gt;</span><br><span class="line">            &lt;PatternLayout pattern&#x3D;&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;&#x2F;&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy&#x2F;&gt;</span><br><span class="line">                &lt;SizeBasedTriggeringPolicy size&#x3D;&quot;100 MB&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Policies&gt;</span><br><span class="line">        &lt;&#x2F;RollingFile&gt;</span><br><span class="line">        &lt;RollingFile name&#x3D;&quot;RollingFileWarn&quot; fileName&#x3D;&quot;$&#123;sys:user.home&#125;&#x2F;logs&#x2F;warn.log&quot;</span><br><span class="line">                     filePattern&#x3D;&quot;$&#123;sys:user.home&#125;&#x2F;logs&#x2F;$$&#123;date:yyyy-MM&#125;&#x2F;warn-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;</span><br><span class="line">            &lt;ThresholdFilter level&#x3D;&quot;warn&quot; onMatch&#x3D;&quot;ACCEPT&quot; onMismatch&#x3D;&quot;DENY&quot;&#x2F;&gt;</span><br><span class="line">            &lt;PatternLayout pattern&#x3D;&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;&#x2F;&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy&#x2F;&gt;</span><br><span class="line">                &lt;SizeBasedTriggeringPolicy size&#x3D;&quot;100 MB&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Policies&gt;</span><br><span class="line">            &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;</span><br><span class="line">            &lt;DefaultRolloverStrategy max&#x3D;&quot;20&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;RollingFile&gt;</span><br><span class="line">        &lt;RollingFile name&#x3D;&quot;RollingFileError&quot; fileName&#x3D;&quot;$&#123;sys:user.home&#125;&#x2F;logs&#x2F;error.log&quot;</span><br><span class="line">                     filePattern&#x3D;&quot;$&#123;sys:user.home&#125;&#x2F;logs&#x2F;$$&#123;date:yyyy-MM&#125;&#x2F;error-%d&#123;yyyy-MM-dd&#125;-%i.log&quot;&gt;</span><br><span class="line">            &lt;ThresholdFilter level&#x3D;&quot;error&quot; onMatch&#x3D;&quot;ACCEPT&quot; onMismatch&#x3D;&quot;DENY&quot;&#x2F;&gt;</span><br><span class="line">            &lt;PatternLayout pattern&#x3D;&quot;[%d&#123;HH:mm:ss:SSS&#125;] [%p] - %l - %m%n&quot;&#x2F;&gt;</span><br><span class="line">            &lt;Policies&gt;</span><br><span class="line">                &lt;TimeBasedTriggeringPolicy&#x2F;&gt;</span><br><span class="line">                &lt;SizeBasedTriggeringPolicy size&#x3D;&quot;100 MB&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;Policies&gt;</span><br><span class="line">        &lt;&#x2F;RollingFile&gt;</span><br><span class="line">    &lt;&#x2F;appenders&gt;</span><br><span class="line">    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span><br><span class="line">    &lt;loggers&gt;</span><br><span class="line">        &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span><br><span class="line">        &lt;logger name&#x3D;&quot;org.springframework&quot; level&#x3D;&quot;INFO&quot;&gt;&lt;&#x2F;logger&gt;</span><br><span class="line">        &lt;logger name&#x3D;&quot;org.mybatis&quot; level&#x3D;&quot;INFO&quot;&gt;&lt;&#x2F;logger&gt;</span><br><span class="line">        &lt;root level&#x3D;&quot;all&quot;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;Console&quot;&#x2F;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;RollingFileInfo&quot;&#x2F;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;RollingFileWarn&quot;&#x2F;&gt;</span><br><span class="line">            &lt;appender-ref ref&#x3D;&quot;RollingFileError&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;root&gt;</span><br><span class="line">    &lt;&#x2F;loggers&gt;</span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p><em>打印信息</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[23:04:14:602] [TRACE] - com.dancer4code.slf4j.Slf4jTest.main(Slf4jTest.java:17) - hello trace</span><br><span class="line">[23:04:14:605] [DEBUG] - com.dancer4code.slf4j.Slf4jTest.main(Slf4jTest.java:18) - hello debug</span><br><span class="line">[23:04:14:605] [ INFO] - com.dancer4code.slf4j.Slf4jTest.main(Slf4jTest.java:19) - hello info</span><br><span class="line">[23:04:14:606] [ WARN] - com.dancer4code.slf4j.Slf4jTest.main(Slf4jTest.java:20) - hello warn</span><br><span class="line">[23:04:14:607] [ERROR] - com.dancer4code.slf4j.Slf4jTest.main(Slf4jTest.java:21) - hello error</span><br></pre></td></tr></table></figure>
<p><em>参考了</em><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/v123411739/article/details/80232005">Log4j2与Slf4j的最佳实践</a><br><a target="_blank" rel="noopener" href="https://www.imooc.com/article/78966">浅谈Log4j2日志框架及使用</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/jdbdh/article/details/88012456">Log4j2</a><br><a target="_blank" rel="noopener" href="http://ifeve.com/slf4j-manual/">SLF4J 使用手册</a><br><code>**谢谢上面的博客参考**</code></p>
<h1 id="3-补充"><a href="#3-补充" class="headerlink" title="3.补充"></a>3.补充</h1><p>日志级别共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF.</p>
<p>slf4j日志级别代码中只支持<br> Trace &lt; Debug &lt; Info &lt; Warn &lt; Error</p>
<p>源码gitee地址—-<a target="_blank" rel="noopener" href="https://gitee.com/dancer4code/slf4jtest">slf4jtest</a></p>
<p>log4j pattern请参考<br><a target="_blank" rel="noopener" href="http://logging.apache.org/log4j/2.x/manual/layouts.html">Apache官方pattern</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/garfielder007/article/details/82874529">Log4j输出格式控制–log4j的PatternLayout参数含义</a><br> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/sagech/p/9278715.html">log4j日志pattern配置</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/logging/" rel="tag">logging</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-linux/linux学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/07/linux/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >linux学习笔记</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/07/linux/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-07-07T14:36:00.000Z" itemprop="datePublished">2020-07-07</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><code>whoami</code>当前用户名<br><code>who am i</code>当前用户名  登陆的终端 当前的日期和时间<br><code>who</code>哪些用户在系统上工作<br><code>w 比who</code>更全面</p>
<hr>
<p><code>users</code> 所有用户<br><code>tty</code> 目前登陆系统所使用的终端</p>
<hr>
<p><code>uname --help</code>查看所有uname命令命令<br><code>uname --version</code><br><code>uname [-a|--all]</code>所有信息<br><code>uname [-n|--nodename]</code>所使用系统的主机名<br><code>uname [-s|--kernel-name]</code>操作系统名<br><code>uname [-r|--kernel-release]</code>操作系统发布版本信息<br><code>uname [-v|--kernel-version]</code><br><code>uname [-m|--machine]</code>machine hardware name<br><code>uname [-p|--processor]</code>processor type<br><code>uname [-i|--hardware-platform]</code><br><code>uname [-o|--operating-system]</code></p>
<hr>
<p> <code>date </code>显示系统日期和时间<br> <code>cal</code> 显示本月日历（calendar）<br> <code>cal 7 2019</code> 显示2019年7月日历<br><code>cal 2019</code>显示2019年日历</p>
<p><code>clear</code>清除终端窗口中的显示</p>
<p><code>不能用root用户直接telnet操作</code></p>
<p><code>#root</code>用户提示符<br><code>$</code>普通用户提示符<br><code>su命令（switch user）</code><br><code>su  - root </code>切换root用户<br><code>su - </code>默认切换到root<br><code>exit </code>退出超级用户</p>
<hr>
<p><code>passwd </code>修改密码命令<code>password</code></p>
<p><code>whatis who</code>  命令<code>who</code>的作用概括<br>或<br><code>man -f who</code></p>
<p><code>who --help </code><br>或<br><code>man who</code> 查看<code>who</code>命令帮助<code>man</code>(<code>manual</code>手册)</p>
<p><code>info who</code>  帮助更易理解</p>
<hr>
<p><code>/etc </code>系统主要配置文件<br><code>/tmp</code> 临时文件<br><code>/boot</code> 系统内核文件<br><code>/usr (unix sysytm resources)</code>系统应用程序和与命令相关的系统数据<br><code>/dev</code> 系统设备<br><code>Lost+Found </code>系统异常崩溃错误 ，系统将一些遗失的片段放入其中，系统自动过生成。<br><code>/var </code>存放系统运行时经常变化的文件，如<code>log ,mail</code><br><code>/srv</code>存放的所有与服务器相关的服务，即一些服务启动后，这些服务需要访问的目录。<br><code>/proc</code> 虚拟文件系统，常驻内存中不占磁盘空间，存放系统运行所需的信息。<br><code>/lib 、usr/lib、usr/local/lib </code>系统使用的函数库。程序运行中需要调用的库函数</p>
<hr>
<p><code>cd</code>命令(<code>change directory</code>)<br><code>cd</code>进入目录<br><code>cd . </code>当前目录<br><code>cd ..</code>上一层目录<br><code>cd /</code>根目录<br><code>cd </code>或<code>cd ~ </code>或<code>cd $HOME </code>切换到用户家目录<br><code>cd -</code>切换到用户之前的工作目录</p>
<hr>
<p><code>pwd</code><br>打印当前工作目录（<code>print working directory</code>）</p>
<p><code>ls(list)</code><br><code>ls -a</code>列举所有文件及文件夹包括隐藏<code>-a(all)</code><br><code>ls -l </code> 列出非隐藏文件细节<code>-l（long）</code><br><code>ls -R </code>列出本目录及子目录内容<br><code>ls -F</code> 列出目录中文件（可执行文件（*），目录（/）,超链（@））</p>
<hr>
<p><code>mkdir(make directory)</code>创建文件夹</p>
<p><code>&gt;</code> 重新创建创建文件</p>
<p><code>touch</code>创建文件，如果不存在则创建，如果存在则更新时间戳</p>
<p><code>mkdir aa</code> 创建文件夹aa<br><code>mkir -p aa/bb/cc</code>不存在就创建<br><code>-p(parents)</code><br><code>&gt;bb.txt </code>每次都是重新创建创建文件bb.txt</p>
<p><code>ls -l /lib &gt;cc.txt</code> 创建文件cc.txt并把列举lib下所有文件信息写入</p>
<p><code>ls -lh</code>文件大小变为熟悉方式<code> -h(human)</code></p>
<hr>
<p><code>cp(copy)</code></p>
<p><code>cp [options] [sources] [target]</code></p>
<p><code>cp -i|-r|-p|-f aa /home</code>复制aa文件夹道home下<br><code>-i(interactive交互的)</code>覆盖时有提示信息<br><code>-r(recursive递归的)</code>复制该目录及该目录下的全部内容<br><code>-p(preserve维持)</code>保留一些属性如时间戳<br><code>-f(force强制)</code>存在即直接覆盖</p>
<p><code>普通用户cp -f</code>强制覆盖<br><code>root用户cp -i</code>提示信息</p>
<hr>
<p><code>mv(move)</code>移动目录及其目录下的内容</p>
<p><code>mv aa.txt bb.txt</code></p>
<p><code>rm(remove)删除</code></p>
<p><code>rm -i|-r|-f </code><br><code>rm -r aa</code>删除aa及aa下的文件及目录<br><code>rmdir</code>只能删除当前空文件夹</p>
<hr>
<p><code>yum install vsftpd</code><br>安装<code>vsftpd</code></p>
<p><code>service vsftpd status </code><br><code>systemctl status vsftpd</code> 查看<code>vsftpd</code>服务状态</p>
<p><code>service sftpd start</code><br><code>systemctl enable vsftpd</code>开启服务</p>
<hr>
<p><code>ftp </code>主机名|ip端口<br><code>ftp&gt;</code><br><code>bye</code>或<code>quit</code>退出</p>
<p><code>lcd </code>查看和改变本地路径<br><code>cd ls</code>查看改变linux路径</p>
<p><code>open </code>主机|ip端口 建立一个新连接<br>切换模式<br><code>ascii </code>纯文本模式<br><code>bin </code>二进制模式</p>
<p><code>put filename </code>传输一个文件<br><code>mput file1 file2</code> 传输多个文件</p>
<p><code>prompt</code>开启/关闭交互信息</p>
<p><code>get file</code><br><code>mget file1 file2</code>从linux到windows</p>
<hr>
<p><code>file </code>查看文件类型，linux扩展名并不代表文件类型</p>
<p><code>file aa</code><br><code>file</code> 与<code>ls -F</code>类似，只不过更详细</p>
<hr>
<p><code>cat</code>浏览文件内容（<code>concatenate</code>）</p>
<p><code>cat -A|-s|-b file1 file2</code> 把file1和file连接到一起显示<br><code>-A</code>显示换行符<br><code>-s</code>压缩多个空行为一行<br><code>-b</code>显示行号</p>
<p><code>cat&gt;file</code><br><code>you can to create a new file to use cat &gt; command</code><br>创建一个file并写入you can to create a new file to use cat &gt; command 用<code>ctrl+D</code>保存结束</p>
<hr>
<p><code>head -n|--line 10 file </code>查看file的前10行<br>或者<br><code>head -10 file</code>与上一样</p>
<hr>
<p><code>tail -n|--line 10 file</code> 查看文件最后10行<br><code>tail -10 file</code> </p>
<p><code>tail -f|--follow file</code>动态监控文件变化是显示在屏幕上<br><code>tail -f log </code>监控log文件</p>
<p><code>wc (word count)</code>查看文件行数、单词数、字符数<br><code>wc -l|-w|-c  -l line  -w word -c character</code></p>
<hr>
<p><code>more </code>如果一个文件较大用more查看<br><code>空格键</code>:向下移动一屏幕<br><code>enter键</code>:一次移动一行<br><code>B</code>:向上移动一屏幕<br><code>H</code>:帮助<br><code>/字符串</code>：向下搜索这个字符串<br><code>N</code>:字符串下一次出现<br><code>Q</code>:退出more命令<br><code>V</code>:在当前行启动vi</p>
<hr>
<p><code>type -t|-a|-P ls</code><br><code>-t file</code>为外部命令 alias为别名 builtin为bash内置命令<br><code>-a</code>列出包含指定命令的命令包括别名<br><code>-P</code>显示完整的文件名（外部命令），或者为内部命令</p>
<hr>
<p>linux中的通配符</p>
<p><code>*</code>：匹配0个或多个字符<br><code>？</code>：匹配一个字符<br><code>[a-z]</code>:匹配a<del>z范围内的字符<br><code>[^a-z]</code>:匹配a</del>z之外的字符<br><code>[abc]</code>:匹配括号中的任意字符<br><code>[^abc]</code>：匹配不包含括号内的字符</p>
<hr>
<p><code>~ 符号</code><br><code>~后面没跟用户</code> 代表当前用户家目录<br><code>~跟了用户名</code> 这个用户的家目录</p>
<hr>
<p><code>history </code>查看执行命令的历史<br> <code>！行号</code> 执行该命 令</p>
<p><code>bash变量和&#123;&#125;用法</code></p>
<p><code>$PATH</code>执行命令时要搜索的路径，即一个命令如果存储在PATH的预定义变量用户可以只输入变量名来执行命令<br><code>echo $PATH</code><br><code>$HOME</code>用户家路径</p>
<p><code>&#123;&#125;</code><br><code>touch a.&#123;b,c&#125;.&#123;txt,jpg&#125;</code><br>则会创建 a.b.txt a.b.jpg a.c.txt a.c.jpg四个文件 其他命令使用{}也变得更方便。</p>
<hr>
<p>讲一个命令的输出作为另一个命令的参数<br><code>hostname</code> 主机名</p>
<p><code>echo &quot;this is </code>hostname<code>&quot;</code><br><code>echo &quot;this is $(hostname)&quot;</code><br><code>echo &quot;Today is </code>date<code>&quot;</code><br><code>echo &quot;Today is $(date)&quot;</code></p>
<hr>
<p>linux 命令数学运算</p>
<p>a=10;b=5,c=3</p>
<p><code>echo $[$a+$b]</code><br><code>echo $[$a-$b]</code><br><code>echo $[$a*$b]</code><br><code>echo $[$a/$b]</code><br><code>echo $[$a%$b]</code><br><code>echo $[$a**$c]</code> 10的三次方</p>
<hr>
<p><code>反斜杠\用法</code></p>
<p><code>\$a</code>不作为一个变量输出$a<br><code>\*</code>不作为通配符输出*<br>命令行最后使用\表示命令下一行继续。</p>
<p><code>单引号（&#39;）与双引号（&quot;）</code><br>1.单引号：禁止所有命令行扩展功能<br>2.禁止除下面意外的命令行扩展功能<br>   美元符号$<br>   倒引号 `<br>   反斜杠 /<br>   感叹号 !</p>
<hr>
<p><code>文件描述符</code><br><code>fd(file descriptor)</code></p>
<p>0:标准命令输入 <code>stdin</code><br>1:标准命令输出 <code>stdout</code><br>2:标准命令错误 <code>stderr</code></p>
<p><code>ls -l /dev/std*</code> 文件描述符与缩写对应关系查询</p>
<hr>
<p><code>使用find搜索文件和目录</code><br><code>find pathnames expressions actions</code><br><code>pathnames</code>:搜索起始绝对路径或相对路径<br><code>expressions</code>：由一个或多个选项第一的搜索条件 多个选项关系时逻辑与（and）<br>    <code> -name</code>:文件名，使用通配符时最好放入””内<br>    <code> -size [+|-]n</code>: 大小大于 +n  小于 -n 或等于 n ,n代表512字节大小数据块的个数。<br>     <code>-atime [+|-]n</code>:查找访问时间超过天数 +n  低于 -n ,等于 n<br>     <code>-mtime [+|-]n</code>:查找更新时间超过天数 +n  低于 -n ,等于 n<br>    <code> -user loginID</code>:查找属于loginID(用户)的所有文件。<br>     <code>-type</code>：查找么某一类文件如f(文件)或d(目录)<br>     <code>-perm</code>:查找所有具有某些特定的访问许可位的文件</p>
<p><code>actions</code>:当文件被定位之后需要进行的操作 默认将满足条件的所有路径打印在屏幕上。<br>    <code> -exec</code> 命令 {} ; :在每一个所定位的文件上运行指定的命令。大括号{}表明文件名将传给前面表达式所表示的命令。<br>        一个空格、一个反斜线和一个分号表示命令的结束。在反斜杠和大括号之间必须有一个空格。<br>     <code>-ok 命令 &#123;&#125; \; </code>:在每个定位文件执行命令之前需要确认。实际就是-exec 命令的交互方式。<br>     <code>-print</code>:打印路径，默认方式<br>    <code> -ls</code>: 显示当前路径名和相关的统计信息，如i节点（inode）数、以K字节为单位的大小（尺寸）、保护模式、硬连接和用户。</p>
<p><code>find / -name &quot;java*&quot; -ls </code>查询根路径下的所有java开头的文件或路径的详细信息</p>
<hr>
<p>将输出重定向到文件中<br><code>&gt;</code>:覆盖原来的内容。<br><code>&gt;&gt;</code>:在原文件之后追加内容。</p>
<p><code>切换普通用户演示</code><br><code>find /etc -name passwd 1&gt;stdout.txt</code><br>相同<br><code>find /etc -name passwd &gt;stdout.txt</code></p>
<p><code>find /etc -name passwd 2&gt;errout.txt</code>输出错误信息到errout.txt</p>
<p><code>find /etc -name passwd &gt;allout.txt 2&gt;&amp;1 </code>标准输出和错误输出合并到一个文件<br><code>find /etc -name passwd &amp;&gt;allout.txt  </code>&amp;代表了所有文件描述符号</p>
<hr>
<p>输入重定向及tr命令<br><code>tr (translate)</code>:转换、压缩和/或删除来自标准输入的字符并将结果写到标准输出上<br>tr命令不接受文件名形式的参数，该命令要求他的输入被重定向为某个地方。</p>
<p>aa.txt<br>内容AAAAA</p>
<p><code>tr &#39;A-Z&#39; &#39;a-z&#39; &lt;aa.txt &gt;bb.txt </code>替换文件aa.txt中的大写字母为小写字母到bb.txt</p>
<p><code>windows 换行</code>（回车符”\r”+换行符（”\n”））<br><code>linux 换行 </code>（换行符（”\n”））</p>
<p><code>tr -d &quot;\r&quot; &lt;aa.txt&gt;cc.txt删除（-d）回车符（\r）</code><br>tr命令的参数部分也是可以使用ascii码字符的八进制表示的数字如 \015 表示\r<br><code>man ascii</code>查看ascii对应信息</p>
<hr>
<p><code>cut 剪切命令</code></p>
<p><code>cut -f|-d|-d file </code><br><code>-f</code>:字段（列）<br><code>-c</code>：要剪切的字符<br><code>-d</code>:字段分隔符（默认Tab）<br><code>cut -f3 bb.txt</code>列出第三个字段<br><code>cut -f2 -d, bb.txt l</code>列出第二个字段以,分隔符  默认分隔符Tab字符</p>
<p><code>cut -c1-3 bb.txt</code>从第一个字符取到第三个字符（按行取）</p>
<hr>
<p><code>paste 粘帖命令</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">user.txt</span><br><span class="line">zlq,11,anhui</span><br><span class="line">fsd,22,anhui</span><br><span class="line">llx,33,fujian</span><br><span class="line">koo,44,guangdong</span><br><span class="line"></span><br><span class="line">[zlq@localhost test]$ cut -f1 -d, &lt;user.txt &gt;name.txt</span><br><span class="line">[zlq@localhost test]$ ls</span><br><span class="line">name.txt  user.txt</span><br><span class="line">[zlq@localhost test]$ cat name.txt </span><br><span class="line">zlq</span><br><span class="line">fsd</span><br><span class="line">ssh</span><br><span class="line">jjg</span><br><span class="line">[zlq@localhost test]$ cut -f2 -d, &lt;user.txt &gt;age.txt</span><br><span class="line">[zlq@localhost test]$ ls</span><br><span class="line">age.txt  name.txt  user.txt</span><br><span class="line">[zlq@localhost test]$ cat age.txt </span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">33</span><br><span class="line">44</span><br><span class="line">[zlq@localhost test]$ cut -f3 -d, &lt;user.txt &gt;addr.txt</span><br><span class="line">[zlq@localhost test]$ ls</span><br><span class="line">addr.txt  age.txt  name.txt  user.txt </span><br><span class="line">[zlq@localhost test]$ cat addr.txt </span><br><span class="line">anhui</span><br><span class="line">anhui</span><br><span class="line">hebei</span><br><span class="line">beijing</span><br><span class="line"></span><br><span class="line">[zlq@localhost test]$ paste name.txt addr.txt &gt;nameaddr.txt</span><br><span class="line">paste name.txt addr.txt &gt;&gt;nameaddr.txt区别</span><br><span class="line">[zlq@localhost test]$ ls</span><br><span class="line">addr.txt  age.txt  nameaddr.txt  name.txt  user.txt</span><br><span class="line">[zlq@localhost test]$ cat nameaddr.txt </span><br><span class="line">zlq	anhui</span><br><span class="line">fsd	anhui</span><br><span class="line">ssh	hebei</span><br><span class="line">jjg	beijing</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">&#96;col将tab替换成空格&#96;</span><br></pre></td></tr></table></figure>
<p>[zlq@localhost test]$ cat -A user1.txt<br>zlq^I11^Ianhui$<br>fsd^I22^Ianhui$<br>ssh^I33^Ihebei$<br>jjg^I44^Ibeijing$<br>[zlq@localhost test]$ col -x &lt;user1.txt&gt;user2.txt<br>[zlq@localhost test]$ cat -A user2.txt<br>zlq     11      anhui$<br>fsd     22      anhui$<br>ssh     33      hebei$<br>jjg     44      beijing$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;sort命令进行排序&#96;</span><br></pre></td></tr></table></figure>
<p>sort [options] [filename]<br>-r: 反向排序（降序) reverse<br>-f:忽略字符大小写 folds<br>-n:以数字顺序进行排序 numeric<br>-u:去掉重复行 unique<br>-t: -tc表示以字符c作为分隔符<br>-k: kN表示按第N个字段排序 k N1,N2先按N1排序，如果重复按N2排序</p>
<p>sort -r name.txt</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#96;uniq命令去掉文件中相邻的重复行&#96;</span><br><span class="line"></span><br><span class="line">&gt;-c:行前显示该行出现的次数</span><br><span class="line">-d:只显示重复行</span><br><span class="line">-i:忽略字符大小写</span><br><span class="line">-u:只显示出现一次的行。</span><br><span class="line"></span><br><span class="line">sort -cid aa.txt 忽略大小写显示重复行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;管道（|）操作&#96;</span><br><span class="line"></span><br><span class="line">&#96;命令1|命令2|.....&#96;</span><br><span class="line">命令1的输出作为命令2的输入</span><br><span class="line"></span><br><span class="line">&#96;cut -f1 -d: &#x2F;etc&#x2F;passwd |sort -r |more&#96; 查看linux系统所有用户名</span><br></pre></td></tr></table></figure>
<p>[root@localhost test]# ls<br>1.txt  3.jpg  4.txt  4.zip<br>[root@localhost test]# cat&gt;delete_lists<br>1.txt<br>3.jpg<br>4.txt<br>4.zip<br>[root@localhost test]# cat delete_lists<br>1.txt<br>3.jpg<br>4.txt<br>4.zip<br>[root@localhost test]# cat delete_lists |xargs rm -f<br>[root@localhost test]# ls<br>delete_lists</p>
<pre><code>`cat命令列出delete_lists`文件名 xargs命令将由管道得来的文件名转换成rm -f的参数列表

使用`tee`命令分流输出
`cut -f1 -d: /etc/passwd |tee passwd.cut |sort -r |tee passwd.sort |more`


`mail` 发送电子邮件
`mail -s &quot;hello&quot; `用户或邮箱
`-s subject`

`ls -l |mail -s &quot;list all&quot; root `列出本目录下的文件发送给root用户</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-java基础/类的加载过程"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/06/java%E5%9F%BA%E7%A1%80/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"
    >类的加载过程</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/06/java%E5%9F%BA%E7%A1%80/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/" class="article-date">
  <time datetime="2020-07-06T14:36:00.000Z" itemprop="datePublished">2020-07-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ul>
<li>查看单例模式时，发现类的加载过程有点忘了（全部都被我当饭吃了，<code>（*_*）</code>）。因此在这里记录下。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">package com.d4c.order;</span><br><span class="line"></span><br><span class="line">public class A &#123;</span><br><span class="line">    public static final int staticFiledA &#x3D; 1;</span><br><span class="line">    public final int filedA &#x3D; 2;</span><br><span class="line"></span><br><span class="line">    A() &#123;</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;A constructor&quot;);</span><br><span class="line">        System.out.println(&quot;staticFiledA:&quot; + staticFiledA);</span><br><span class="line">        System.out.println(&quot;filedA:&quot; + filedA);</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;A static code block&quot;);</span><br><span class="line">        System.out.println(&quot;staticFiledA:&quot; + staticFiledA);</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;A code block&quot;);</span><br><span class="line">        System.out.println(&quot;staticFiledA:&quot; + staticFiledA);</span><br><span class="line">        System.out.println(&quot;filedA:&quot; + filedA);</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final void staticMethodA() &#123;</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;A static method&quot;);</span><br><span class="line">        System.out.println(&quot;staticFiledA:&quot; + staticFiledA);</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;-------------------------------------------</span><br><span class="line"></span><br><span class="line">package com.d4c.order;</span><br><span class="line"></span><br><span class="line">public class B extends A&#123;</span><br><span class="line"></span><br><span class="line">    public static final int staticFiled &#x3D; 3;</span><br><span class="line">    public final int filed &#x3D; 4;</span><br><span class="line"></span><br><span class="line">    B() &#123;</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;B constructor&quot;);</span><br><span class="line">        System.out.println(&quot;staticFiled:&quot; + staticFiled);</span><br><span class="line">        System.out.println(&quot;filed:&quot; + filed);</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;B static code block&quot;);</span><br><span class="line">        System.out.println(&quot;staticFiled:&quot; + staticFiled);</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;B code block&quot;);</span><br><span class="line">        System.out.println(&quot;staticFiled:&quot; + staticFiled);</span><br><span class="line">        System.out.println(&quot;filed:&quot; + filed);</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final void staticMethod() &#123;</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;B static method&quot;);</span><br><span class="line">        System.out.println(&quot;staticFiled:&quot; + staticFiled);</span><br><span class="line">        System.out.println(&quot;------------------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        B b &#x3D; new B();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">------------------------------</span><br><span class="line">A static code block</span><br><span class="line">staticFiledA:1</span><br><span class="line">------------------------------</span><br><span class="line">------------------------------</span><br><span class="line">B static code block</span><br><span class="line">staticFiled:3</span><br><span class="line">------------------------------</span><br><span class="line">------------------------------</span><br><span class="line">A code block</span><br><span class="line">staticFiledA:1</span><br><span class="line">filedA:2</span><br><span class="line">------------------------------</span><br><span class="line">------------------------------</span><br><span class="line">A constructor</span><br><span class="line">staticFiledA:1</span><br><span class="line">filedA:2</span><br><span class="line">------------------------------</span><br><span class="line">------------------------------</span><br><span class="line">B code block</span><br><span class="line">staticFiled:3</span><br><span class="line">filed:4</span><br><span class="line">------------------------------</span><br><span class="line">------------------------------</span><br><span class="line">B constructor</span><br><span class="line">staticFiled:3</span><br><span class="line">filed:4</span><br><span class="line">------------------------------</span><br></pre></td></tr></table></figure>

<p><strong>结论：</strong><br><strong>静态变量：</strong></p>
<ul>
<li>可以将静态变量理解为类变量（与对象无关），而实例变量则属于一个特定的对象。</li>
<li>静态变量有两种情况：<ul>
<li>静态变量是基本数据类型，这种情况下在类的外部不必创建该类的实例就可以直接使用</li>
<li>静态变量是一个引用。这种情况比较特殊，主要问题是由于静态变量是一个对象的引用，那么必须初始化这个对象之后才能将引用指向它。因此如果要把一个引用定义成static的，就必须在定义的时候就对其对象进行初始化。</li>
</ul>
</li>
</ul>
<p><strong>静态方法：</strong></p>
<ul>
<li>在内存中只有一份。</li>
<li>静态方法可以直接使用，而实例方法必须在类实例化之后通过对象来调用。</li>
<li>在外部调用静态方法时，可以使用“类名.方法名”或者“对象名.方法名”的形式。</li>
<li>实例方法只能使用这种方式对象名.方法名。</li>
<li>静态方法只允许访问静态成员。而实例方法中可以访问静态成员和实例成员。</li>
<li>静态方法中不能使用this（因为this是与实例相关的）。</li>
</ul>
<p><strong>静态代码块:</strong></p>
<ul>
<li>静态代码块会在类被加载时自动执行。</li>
<li>静态代码块只能定义在类里面，不能定义在方法里面。</li>
<li>静态代码块里的变量都是局部变量，只在块内有效。</li>
<li>一个类中可以定义多个静态代码块，按顺序执行。</li>
<li>静态代码块只能访问类的静态成员，而不允许访问实例成员。</li>
</ul>
<p><strong>顺序</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类的静态字段——&gt;父类静态代码块——&gt;子类静态字段——&gt;子类静态代码块——&gt;父类成员变量（非静态字段）——&gt;父类非静态代码块——&gt;父类构造器——&gt;子类成员变量——&gt;子类非静态代码块——&gt;子类构造器</span><br></pre></td></tr></table></figure>


<p><strong>引用参考</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36522306/article/details/80584595">java中类加载与静态变量、静态方法与静态代码块详解与初始化顺序</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-java基础/单例模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/05/java%E5%9F%BA%E7%A1%80/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"
    >单例模式</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/05/java%E5%9F%BA%E7%A1%80/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-07-05T14:36:00.000Z" itemprop="datePublished">2020-07-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>一般实现单例模式的几种思路<br><strong>懒汉和饿汉</strong></p>
<ul>
<li>饿汉式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。</li>
<li>懒汉式：在类加载时不初始化，等到第一次被使用时才初始化。</li>
</ul>
<p>##1.饿汉式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.d4c.example;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 饿汉式</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonHungry &#123;</span><br><span class="line">    private final static SingletonHungry SINGLETON_HUNGRY &#x3D; new SingletonHungry();</span><br><span class="line"></span><br><span class="line">    private SingletonHungry() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonHungry getInstance() &#123;</span><br><span class="line">        return SINGLETON_HUNGRY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>优点：在类加载的时候就完成了实例化，避免了多线程的同步问题。</li>
<li>缺点：因为类加载时就实例化了，没有达到Lazy Loading (懒加载) 的效果，如果该实例没被使用，内存就浪费了。</li>
</ul>
<p>##2.懒汉式（同步方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.d4c.example;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 懒汉式</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonLazy &#123;</span><br><span class="line">    </span><br><span class="line">    private static SingletonLazy singletonLazy &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private SingletonLazy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized SingletonLazy getInstance() &#123;</span><br><span class="line">        if (singletonLazy &#x3D;&#x3D; null) &#123;</span><br><span class="line">            singletonLazy &#x3D; new SingletonLazy();</span><br><span class="line">        &#125;</span><br><span class="line">        return singletonLazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>优点:对getInstance()加了锁的处理，保证了同一时刻只能有一个线程访问并获得实例.</li>
<li>缺点:也很明显，因为synchronized是修饰整个方法，每个线程访问都要进行同步，而其实这个方法只执行一次实例化代码就够了，每次都同步方法显然效率低下，为了改进这种写法，就有了下面的双重检查懒汉式。</li>
</ul>
<h2 id="3-懒汉式（双重校验锁）"><a href="#3-懒汉式（双重校验锁）" class="headerlink" title="3.懒汉式（双重校验锁）"></a>3.懒汉式（双重校验锁）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.d4c.example;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 懒汉式（DBL）</span><br><span class="line"> * volatile关键字修饰，防止指令重排</span><br><span class="line"> * Double Check Lock（DCL） 双重锁校验</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonLazyDBL &#123;</span><br><span class="line"></span><br><span class="line">    private static volatile SingletonLazyDBL singletonLazy &#x3D; null;</span><br><span class="line"></span><br><span class="line">    private SingletonLazyDBL() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonLazyDBL getInstance() &#123;</span><br><span class="line">        if (singletonLazy &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (SingletonLazyDBL.class) &#123;</span><br><span class="line">                if (singletonLazy &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    singletonLazy &#x3D; new SingletonLazyDBL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singletonLazy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>优点：用了两个if判断，也就是Double-Check，并且同步的不是方法，而是代码块，效率较高。</li>
</ul>
<blockquote>
<p>为什么要做两次判断呢？这是为了线程安全考虑，还是那个场景，对象还没实例化，两个线程A和B同时访问静态方法并同时运行到第一个if判断语句，这时线程A先进入同步代码块中实例化对象，结束之后线程B也进入同步代码块，如果没有第二个if判断语句，那么线程B也同样会执行实例化对象的操作了。</p>
</blockquote>
<h2 id="4-静态内部类方式"><a href="#4-静态内部类方式" class="headerlink" title="4.静态内部类方式"></a>4.静态内部类方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.d4c.example;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 懒汉式（内部类方式）</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonInnerType &#123;</span><br><span class="line"></span><br><span class="line">    private SingletonInnerType() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        public static volatile SingletonInnerType SINGLETON_INNER_TYPE &#x3D; new SingletonInnerType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonInnerType getInstance() &#123;</span><br><span class="line">        return SingletonHolder.SINGLETON_INNER_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>似乎静态内部类看起来已经是最完美的方法了，其实不是，可能还存在反射攻击或者反序列化攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">       SingletonInnerType singleton &#x3D; SingletonInnerType.getInstance();</span><br><span class="line">       Constructor&lt;SingletonInnerType&gt; constructor &#x3D; SingletonInnerType.class.getDeclaredConstructor();</span><br><span class="line">       constructor.setAccessible(true);</span><br><span class="line">       SingletonInnerType newSingleton &#x3D; constructor.newInstance();</span><br><span class="line">       System.out.println(singleton &#x3D;&#x3D; newSingleton);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者引入反序列化后，也不是单例的了。</p>
<p>反序列化须引入依赖（方便操作）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">      SingletonInnerType instance &#x3D; SingletonInnerType.getInstance();</span><br><span class="line">      System.out.println(&quot;instance &#x3D; &quot; + instance);</span><br><span class="line">      byte[] serialize &#x3D; SerializationUtils.serialize(instance);</span><br><span class="line">      SingletonInnerType newInstance &#x3D; SerializationUtils.deserialize(serialize);</span><br><span class="line">      System.out.println(&quot;newInstance &#x3D; &quot; + newInstance);</span><br><span class="line">      System.out.println(instance &#x3D;&#x3D; newInstance);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>所以，反射攻击或者反序列化都导致单例失败。</p>
<p>解决方法，禁止反射就可以了。<br><strong>优化后</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.d4c.example;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 懒汉式（内部类方式）</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SingletonInnerType &#123;</span><br><span class="line"></span><br><span class="line">    private SingletonInnerType() &#123;</span><br><span class="line">        throw new RuntimeException(&quot;破解错误！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        public static volatile SingletonInnerType SINGLETON_INNER_TYPE &#x3D; new SingletonInnerType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static SingletonInnerType getInstance() &#123;</span><br><span class="line">        return SingletonHolder.SINGLETON_INNER_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        SingletonInnerType singleton &#x3D; SingletonInnerType.getInstance();</span><br><span class="line">        Constructor&lt;SingletonInnerType&gt; constructor &#x3D; SingletonInnerType.class.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(true);</span><br><span class="line">        SingletonInnerType newSingleton &#x3D; constructor.newInstance();</span><br><span class="line">        System.out.println(singleton &#x3D;&#x3D; newSingleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>优点：线程安全，调用效率高，可以延时加载</li>
</ul>
<blockquote>
<p>这是很多开发者推荐的一种写法，这种静态内部类方式在SingletonInnerType 类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonHolder 类，从而完成对象的实例化。同时，因为类的静态属性只会在第一次加载类的时候初始化，也就保证了SingletonHolder 中的对象只会被实例化一次，并且这个过程也是线程安全的。</p>
</blockquote>
<p>##5.枚举方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.d4c.example;</span><br><span class="line"></span><br><span class="line">public enum SingletonEnum &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 实例化对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    private Singleton instance &#x3D; null;</span><br><span class="line"></span><br><span class="line">    SingletonEnum() &#123;</span><br><span class="line">        instance &#x3D; new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class Singleton &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种写法在《Effective JAVA》中大为推崇，它可以解决两个问题：</p>
<ul>
<li><p>1）线程安全问题。因为Java虚拟机在加载枚举类的时候会使用ClassLoader的方法，这个方法使用了同步代码块来保证线程安全。</p>
</li>
<li><p>2）避免反序列化破坏对象，因为枚举的反序列化并不通过反射实现。<br>好了，单例模式的几种写法就介绍到这了，最后简单总结一下单例模式的优缺点</p>
</li>
<li><p>缺点：不能延时加载。</p>
</li>
</ul>
<p><strong>总结：</strong></p>
<blockquote>
<p>匿名内部类的方式和单元素的枚举类型能够防住反射或反序列化的攻击，其他几种则不行。所以推荐这两种方式创建单例。</p>
</blockquote>
<p><strong>引用文章</strong><br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903849581346823">设计模式：单例模式 (关于饿汉式和懒汉式)</a><br><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904168566554638">【一起学系列】之单例模式：只推荐三种~</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/yy254117440/article/details/52305175">Java 利用枚举实现单例模式</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/happy4java/p/11206105.html">Java单例模式：为什么我强烈推荐你用枚举来实现单例模式</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34203492/article/details/84336492">Java单例—反射攻击破坏单例和解决方法</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-java基础/JDK5，6，7，8，9，10，11，12，13特性"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/04/java%E5%9F%BA%E7%A1%80/JDK5%EF%BC%8C6%EF%BC%8C7%EF%BC%8C8%EF%BC%8C9%EF%BC%8C10%EF%BC%8C11%EF%BC%8C12%EF%BC%8C13%E7%89%B9%E6%80%A7/"
    >JDK5，6，7，8，9，10，11，12，13特性</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/04/java%E5%9F%BA%E7%A1%80/JDK5%EF%BC%8C6%EF%BC%8C7%EF%BC%8C8%EF%BC%8C9%EF%BC%8C10%EF%BC%8C11%EF%BC%8C12%EF%BC%8C13%E7%89%B9%E6%80%A7/" class="article-date">
  <time datetime="2020-07-04T14:36:00.000Z" itemprop="datePublished">2020-07-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="JDK5"><a href="#JDK5" class="headerlink" title="JDK5"></a>JDK5</h3><h4 id="1-泛型-Generics"><a href="#1-泛型-Generics" class="headerlink" title="1.泛型 (Generics)"></a>1.泛型 (Generics)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>

<h4 id="2-增强循环（Enhanced-for-Loop）"><a href="#2-增强循环（Enhanced-for-Loop）" class="headerlink" title="2.增强循环（Enhanced for Loop）"></a>2.增强循环（Enhanced for Loop）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i : array) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h4 id="3-自动封箱拆箱-Autoboxing-Unboxing"><a href="#3-自动封箱拆箱-Autoboxing-Unboxing" class="headerlink" title="3.自动封箱拆箱(Autoboxing/Unboxing )"></a>3.自动封箱拆箱(Autoboxing/Unboxing )</h4><p>八大基本类型和它们的包装类能够自动的相互转换。</p>
<table>
<thead>
<tr>
<th>简单类型</th>
<th>boolean</th>
<th>byte</th>
<th>char</th>
<th>short</th>
<th>Int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>void</th>
</tr>
</thead>
<tbody><tr>
<td>二进制位数</td>
<td>1</td>
<td>8</td>
<td>16</td>
<td>16</td>
<td>32</td>
<td>64</td>
<td>32</td>
<td>64</td>
<td>–</td>
</tr>
<tr>
<td>封装器类</td>
<td>Boolean</td>
<td>Byte</td>
<td>Character</td>
<td>Short</td>
<td>Integer</td>
<td>Long</td>
<td>Float</td>
<td>Double</td>
<td>Void</td>
</tr>
</tbody></table>
<h4 id="4-枚举-Typesafe-Enums"><a href="#4-枚举-Typesafe-Enums" class="headerlink" title="4.枚举(Typesafe Enums)"></a>4.枚举(Typesafe Enums)</h4><p>ps:枚举是一种实现线程安全的单例模式的好方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TestEnum</span></span>&#123;</span><br><span class="line">        one,</span><br><span class="line">        two;</span><br><span class="line">        TestEnum() &#123;</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-可变参数-Varargs"><a href="#5-可变参数-Varargs" class="headerlink" title="5.可变参数 (Varargs)"></a>5.可变参数 (Varargs)</h4><ul>
<li>语法：(type… arguments)<br>可变参数本质仍然是用一个数组存储参数，只是java隐藏了这一过程。需要注意的是如果一个方法声明中含有可变参数，那必须放在最后一个位置。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 可变参数测试</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testVarargs</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//本质就是个数组</span></span><br><span class="line">    System.out.println(args[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">        System.out.println(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-静态导入（Static-Import）"><a href="#6-静态导入（Static-Import）" class="headerlink" title="6.静态导入（Static Import）"></a>6.静态导入（Static Import）</h4><p>通过import类来使用类里的静态变量或方法（直接通过名字，不需要加上类名.）,简化了代码的书写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;</span><br><span class="line"><span class="comment">//批量导入</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure>

<p>ps:过去的版本中只能通过继承类或实现接口才能使用。</p>
<h4 id="7-注解（Annotations）-关键字-interface"><a href="#7-注解（Annotations）-关键字-interface" class="headerlink" title="7.注解（Annotations）,关键字@interface"></a>7.注解（Annotations）,关键字@interface</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释注解的注解又叫做元注解</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">    <span class="comment">//注解内可以添加方法，也可以不添加</span></span><br><span class="line">    <span class="comment">//注解方法的返回值只能是基本类型，String，Class类,枚举,注解,可以有默认值。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;whh&quot;</span>;</span><br><span class="line">    <span class="function">Class <span class="title">classType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">TestEnum <span class="title">enumType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-新的线程模型和并发库（java-util-concurrent"><a href="#8-新的线程模型和并发库（java-util-concurrent" class="headerlink" title="8.新的线程模型和并发库（java.util.concurrent)"></a>8.新的线程模型和并发库（java.util.concurrent)</h4><h3 id="JDK6"><a href="#JDK6" class="headerlink" title="JDK6"></a>JDK6</h3><h4 id="1-集合框架增强"><a href="#1-集合框架增强" class="headerlink" title="1.集合框架增强"></a>1.集合框架增强</h4><ul>
<li>为了更好的支持双向访问集合。添加了许多新的类和接口。</li>
<li>新的数组拷贝方法。Arrays.copyOf和Arrays.copyOfRange</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为添加的新接口和类</span></span><br><span class="line">Deque,BlockingDeque,NavigableSet,NavigableMap,ConcurrentNavigableMap，ArrayDeque， ConcurrentSkipListSet ,ConcurrentSkipListMap,ConcurrentSkipListMap ,AbstractMap.SimpleEntry ,AbstractMap.SimpleImmutableEntry</span><br></pre></td></tr></table></figure>

<h4 id="2-Scripting"><a href="#2-Scripting" class="headerlink" title="2.Scripting"></a>2.Scripting</h4><p>可以让其他语言在java平台上运行。 java6包含了一个基于Mozilla Rhino实现的javascript脚本引擎。</p>
<h4 id="3-支持JDBC4-0规范"><a href="#3-支持JDBC4-0规范" class="headerlink" title="3.支持JDBC4.0规范"></a>3.支持JDBC4.0规范</h4><h3 id="JDK7"><a href="#JDK7" class="headerlink" title="JDK7"></a>JDK7</h3><h4 id="1-二进制前缀0b或者0B"><a href="#1-二进制前缀0b或者0B" class="headerlink" title="1.二进制前缀0b或者0B"></a>1.二进制前缀0b或者0B</h4><p>整型（byte, short, int, long）可以直接用二进制表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制字面值前缀0b 或0B</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0b010</span>;<span class="comment">//10进制值为2</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0B010</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-字面常量数字的下划线"><a href="#2-字面常量数字的下划线" class="headerlink" title="2.字面常量数字的下划线"></a>2.字面常量数字的下划线</h4><p>用下划线连接整数提升其可读性，自身无含义，不可用在数字的起始和末尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数字间的下划线不影响实际值</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">1_1</span>;<span class="comment">//值为11</span></span><br></pre></td></tr></table></figure>

<h4 id="3-switch-支持String类型"><a href="#3-switch-支持String类型" class="headerlink" title="3.switch 支持String类型"></a>3.switch 支持String类型</h4><h4 id="4-泛型实例化类型自动推断"><a href="#4-泛型实例化类型自动推断" class="headerlink" title="4.泛型实例化类型自动推断"></a>4.泛型实例化类型自动推断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;String&gt;&gt;(); <span class="comment">// 之前</span></span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; myMap = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">// 现在</span></span><br></pre></td></tr></table></figure>

<h4 id="5-try-with-resources语句"><a href="#5-try-with-resources语句" class="headerlink" title="5.try-with-resources语句"></a>5.try-with-resources语句</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 声明在try括号中的对象称为资源，在方法执行完毕后会被自动关闭,相对与之前必须在finally关闭资源，这一      *特性大大提高了代码的简洁性。</span></span><br><span class="line"><span class="comment">* 所有实现java.lang.AutoCloseable接口的类都作为资源被自动关闭。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String src, String dst)</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">         OutputStream out = <span class="keyword">new</span> FileOutputStream(dst)) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buff)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buff, <span class="number">0</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-单个catch中捕获多个异常类型"><a href="#6-单个catch中捕获多个异常类型" class="headerlink" title="6.单个catch中捕获多个异常类型"></a>6.单个catch中捕获多个异常类型</h4><p>（用| 分割）并通过改进的类型检查重新抛出异常</p>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><h4 id="1-lambada表达式-Lambda-Expressions"><a href="#1-lambada表达式-Lambda-Expressions" class="headerlink" title="1.lambada表达式(Lambda Expressions)"></a>1.lambada表达式(Lambda Expressions)</h4><p>Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中)。</p>
<h4 id="2-方法引用（Method-references）"><a href="#2-方法引用（Method-references）" class="headerlink" title="2.方法引用（Method references）"></a>2.方法引用（Method references）</h4><p>方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<h4 id="3-默认方法（Default-methods）"><a href="#3-默认方法（Default-methods）" class="headerlink" title="3.默认方法（Default methods）"></a>3.默认方法（Default methods）</h4><p>默认方法允许将新功能添加到库的接口中，并确保兼容实现老版本接口的旧有代码。接口新增：默认方法与静态方法</p>
<h4 id="4-重复注解（Repeating-Annotations）"><a href="#4-重复注解（Repeating-Annotations）" class="headerlink" title="4.重复注解（Repeating Annotations）"></a>4.重复注解（Repeating Annotations）</h4><p>重复注解提供了在同一声明或类型中多次应用相同注解类型的能力。</p>
<h4 id="5-类型注解（Type-Annotation）"><a href="#5-类型注解（Type-Annotation）" class="headerlink" title="5.类型注解（Type Annotation）"></a>5.类型注解（Type Annotation）</h4><p>在任何地方都能使用注解，而不是在声明的地方。</p>
<h4 id="6-类型推断增强"><a href="#6-类型推断增强" class="headerlink" title="6.类型推断增强"></a>6.类型推断增强</h4><h4 id="7-方法参数反射（Method-Parameter-Reflection）"><a href="#7-方法参数反射（Method-Parameter-Reflection）" class="headerlink" title="7.方法参数反射（Method Parameter Reflection）"></a>7.方法参数反射（Method Parameter Reflection）</h4><h4 id="8-Stream-API"><a href="#8-Stream-API" class="headerlink" title="8.Stream API"></a>8.Stream API</h4><p>新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。Stream API集成到了Collections API里。</p>
<h4 id="9-HashMap改进"><a href="#9-HashMap改进" class="headerlink" title="9.HashMap改进"></a>9.HashMap改进</h4><p>在键值哈希冲突时能有更好表现。</p>
<h4 id="10-Date-Time-API"><a href="#10-Date-Time-API" class="headerlink" title="10.Date Time API"></a>10.Date Time API</h4><p>加强对日期和时间的处理。</p>
<h4 id="11-java-util-包下的改进"><a href="#11-java-util-包下的改进" class="headerlink" title="11.java.util 包下的改进"></a>11.java.util 包下的改进</h4><p>提供了几个实用的工具类。</p>
<ul>
<li>并行数组排序。</li>
<li>标准的Base64编解码。</li>
<li>支持无符号运算。</li>
</ul>
<h4 id="12-java-util-concurrent-包下增加了新的类和方法"><a href="#12-java-util-concurrent-包下增加了新的类和方法" class="headerlink" title="12.java.util.concurrent 包下增加了新的类和方法"></a>12.java.util.concurrent 包下增加了新的类和方法</h4><ul>
<li>java.util.concurrent.ConcurrentHashMap 类添加了新的方法以支持新的StreamApi和lambada表达式。</li>
<li>java.util.concurrent.atomic 包下新增了类以支持可伸缩可更新的变量。</li>
<li>java.util.concurrent.ForkJoinPool类新增了方法以支持 common pool。</li>
<li>新增了java.util.concurrent.locks.StampedLock类，为控制读/写访问提供了一个基于性能的锁，且有三种模式可供选择。</li>
</ul>
<h4 id="13-HotSpot"><a href="#13-HotSpot" class="headerlink" title="13.HotSpot"></a>13.HotSpot</h4><ul>
<li>删除了 永久代（PermGen）,取代它的是Metaspace（JEP 122）元空间</li>
<li>方法调用的字节码指令支持默认方法。</li>
</ul>
<h3 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h3><h4 id="1-java模块系统-（Java-Platform-Module-System）。"><a href="#1-java模块系统-（Java-Platform-Module-System）。" class="headerlink" title="1.java模块系统 （Java Platform Module System）。"></a>1.java模块系统 （Java Platform Module System）。</h4><h4 id="2-新的版本号格式"><a href="#2-新的版本号格式" class="headerlink" title="2.新的版本号格式"></a>2.新的版本号格式</h4><p>MAJOR.MAJOR.<em>M<strong>A</strong>J<strong>O</strong>R</em>.MINOR.SECURITY.SECURITY.<em>S<strong>E</strong>C<strong>U</strong>R<strong>I</strong>T**Y</em>.PATCH</p>
<h4 id="3-java-shell"><a href="#3-java-shell" class="headerlink" title="3.java shell"></a>3.java shell</h4><p>JShell 工具 jShell命令 ,交互式命令行控制台</p>
<h4 id="4-在private-instance-methods方法上可以使用-SafeVarargs注解。"><a href="#4-在private-instance-methods方法上可以使用-SafeVarargs注解。" class="headerlink" title="4.在private instance methods方法上可以使用@SafeVarargs注解。"></a>4.在private instance methods方法上可以使用@SafeVarargs注解。</h4><h4 id="5-diamond语法与匿名内部类结合使用"><a href="#5-diamond语法与匿名内部类结合使用" class="headerlink" title="5.diamond语法与匿名内部类结合使用"></a>5.diamond语法与匿名内部类结合使用</h4><p>钻石操作符升级 可以有{} </p>
<h4 id="6-下划线不能用在变量名中"><a href="#6-下划线不能用在变量名中" class="headerlink" title="6.下划线不能用在变量名中"></a>6.下划线不能用在变量名中</h4><h4 id="7-支持私有接口方法"><a href="#7-支持私有接口方法" class="headerlink" title="7.支持私有接口方法"></a>7.支持私有接口方法</h4><p>在接口中 jdk7 只能声明全名常量和抽象方法 jdk8 添加了静态方法和默认方法 jdk9添加了私有方法,可以使用diamond语法与匿名内部类结合使用。</p>
<h4 id="8-Javadoc"><a href="#8-Javadoc" class="headerlink" title="8.Javadoc"></a>8.Javadoc</h4><ul>
<li>简化Doclet API。</li>
<li>支持生成HTML5格式。</li>
<li>加入了搜索框,使用这个搜索框可以查询程序元素、标记的单词和文档中的短语。</li>
<li>支持新的模块系统。</li>
</ul>
<h4 id="9-JVM"><a href="#9-JVM" class="headerlink" title="9.JVM"></a>9.JVM</h4><ul>
<li>增强了Garbage-First(G1)并用它替代Parallel GC成为默认的垃圾收集器。</li>
<li>统一了JVM 日志，为所有组件引入了同一个日志系统。</li>
<li>删除了JDK 8中弃用的GC组合。（DefNew + CMS，ParNew + SerialOld，Incremental CMS）。</li>
</ul>
<h4 id="10-properties文件支持UTF-8编码"><a href="#10-properties文件支持UTF-8编码" class="headerlink" title="10.properties文件支持UTF-8编码"></a>10.properties文件支持UTF-8编码</h4><p>之前只支持ISO-8859-1。</p>
<h4 id="11-支持Unicode-8-0"><a href="#11-支持Unicode-8-0" class="headerlink" title="11.支持Unicode 8.0"></a>11.支持Unicode 8.0</h4><p>在JDK8中是Unicode 6.2。</p>
<h4 id="12-目录结构"><a href="#12-目录结构" class="headerlink" title="12.目录结构"></a>12.目录结构</h4><h4 id="13-多版本兼容jar包"><a href="#13-多版本兼容jar包" class="headerlink" title="13.多版本兼容jar包"></a>13.多版本兼容jar包</h4><h4 id="14-异常处理try升级"><a href="#14-异常处理try升级" class="headerlink" title="14.异常处理try升级"></a>14.异常处理try升级</h4><h4 id="15-String底层存储结构的变更"><a href="#15-String底层存储结构的变更" class="headerlink" title="15.String底层存储结构的变更"></a>15.String底层存储结构的变更</h4><p>char数组变成byte字节数组</p>
<h4 id="16-增强了Stream-API"><a href="#16-增强了Stream-API" class="headerlink" title="16.增强了Stream API"></a>16.增强了Stream API</h4><p>在java8基础上，新增加4个方法</p>
<h4 id="17-引入httpClient-api"><a href="#17-引入httpClient-api" class="headerlink" title="17.引入httpClient api"></a>17.引入httpClient api</h4><p>代替原有的HttpURLConnection </p>
<h3 id="Java10"><a href="#Java10" class="headerlink" title="Java10"></a>Java10</h3><h4 id="1-局部变量类型推断（Local-Variable-Type-Inference）"><a href="#1-局部变量类型推断（Local-Variable-Type-Inference）" class="headerlink" title="1.局部变量类型推断（Local-Variable Type Inference）"></a>1.局部变量类型推断（Local-Variable Type Inference）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//之前的代码格式</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.oracle.com/&quot;</span>); </span><br><span class="line">URLConnection conn = url.openConnection(); </span><br><span class="line">Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream()))</span><br><span class="line"><span class="comment">//java10中用var来声明变量</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.oracle.com/&quot;</span>); </span><br><span class="line"><span class="keyword">var</span> conn = url.openConnection(); </span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(conn.getInputStream()));</span><br></pre></td></tr></table></figure>

<p>var是一个保留类型名称，而不是关键字。所以之前使用var作为变量、方法名、包名的都没问题，但是如果作为类或接口名，那么这个类和接口就必须重命名了。</p>
<p>var的使用场景主要有以下四种：</p>
<ul>
<li>本地变量初始化。</li>
<li>增强for循环中。</li>
<li>传统for循环中声明的索引变量。</li>
<li>Try-with-resources 变量。</li>
</ul>
<h4 id="2-Optional类添加了新的方法orElseThrow"><a href="#2-Optional类添加了新的方法orElseThrow" class="headerlink" title="2.Optional类添加了新的方法orElseThrow"></a>2.Optional类添加了新的方法orElseThrow</h4><p>相比于已经存在的get方法，这个方法更推荐使用。</p>
<h4 id="3-GC改进和内存管理"><a href="#3-GC改进和内存管理" class="headerlink" title="3.GC改进和内存管理"></a>3.GC改进和内存管理</h4><h4 id="4-线程本地握手"><a href="#4-线程本地握手" class="headerlink" title="4.线程本地握手"></a>4.线程本地握手</h4><h4 id="5-备用内存设备上的堆分配"><a href="#5-备用内存设备上的堆分配" class="headerlink" title="5.备用内存设备上的堆分配"></a>5.备用内存设备上的堆分配</h4><h4 id="6-其他Unicode语言-标记扩展"><a href="#6-其他Unicode语言-标记扩展" class="headerlink" title="6.其他Unicode语言 - 标记扩展"></a>6.其他Unicode语言 - 标记扩展</h4><h4 id="7-基于Java的实验性JIT编译器"><a href="#7-基于Java的实验性JIT编译器" class="headerlink" title="7.基于Java的实验性JIT编译器"></a>7.基于Java的实验性JIT编译器</h4><h4 id="8-开源根证书"><a href="#8-开源根证书" class="headerlink" title="8.开源根证书"></a>8.开源根证书</h4><h4 id="9-根证书颁发认证（CA）"><a href="#9-根证书颁发认证（CA）" class="headerlink" title="9.根证书颁发认证（CA）"></a>9.根证书颁发认证（CA）</h4><h4 id="10-将JDK生态整合单个存储库"><a href="#10-将JDK生态整合单个存储库" class="headerlink" title="10.将JDK生态整合单个存储库"></a>10.将JDK生态整合单个存储库</h4><h4 id="11-删除工具javah"><a href="#11-删除工具javah" class="headerlink" title="11.删除工具javah"></a>11.删除工具javah</h4><h3 id="Java11"><a href="#Java11" class="headerlink" title="Java11"></a>Java11</h3><h4 id="1-支持Unicode-10-0"><a href="#1-支持Unicode-10-0" class="headerlink" title="1.支持Unicode 10.0"></a>1.支持Unicode 10.0</h4><p>在jdk10中是8.0。</p>
<h4 id="2-标准化HTTP-Client"><a href="#2-标准化HTTP-Client" class="headerlink" title="2.标准化HTTP Client"></a>2.标准化HTTP Client</h4><h4 id="3-编译器线程的延迟分配"><a href="#3-编译器线程的延迟分配" class="headerlink" title="3.编译器线程的延迟分配"></a>3.编译器线程的延迟分配</h4><p>添加了新的命令-XX:+UseDynamicNumberOfCompilerThreads动态控制编译器线程的数量。</p>
<h4 id="4-新的垃圾收集器—ZGC"><a href="#4-新的垃圾收集器—ZGC" class="headerlink" title="4.新的垃圾收集器—ZGC"></a>4.新的垃圾收集器—ZGC</h4><p>ZGC: A Scalable Low-Latency Garbage Collector（一种可伸缩的低延迟垃圾收集器(实验性)）</p>
<h4 id="5-Epsilon"><a href="#5-Epsilon" class="headerlink" title="5.Epsilon"></a>5.Epsilon</h4><p>一款新的实验性无操作垃圾收集器。Epsilon GC 只负责内存分配，不实现任何内存回收机制。这对于性能测试非常有用，可用于与其他GC对比成本和收益。</p>
<h4 id="6-Lambda参数的局部变量语法"><a href="#6-Lambda参数的局部变量语法" class="headerlink" title="6.Lambda参数的局部变量语法"></a>6.Lambda参数的局部变量语法</h4><p>java10中引入的var字段得到了增强，现在可以用在lambda表达式的声明中。如果lambda表达式的其中一个形式参数使用了var，那所有的参数都必须使用var。</p>
<h4 id="7-嵌套类可见性控制"><a href="#7-嵌套类可见性控制" class="headerlink" title="7.嵌套类可见性控制"></a>7.嵌套类可见性控制</h4><h4 id="8-动态文件常量"><a href="#8-动态文件常量" class="headerlink" title="8.动态文件常量"></a>8.动态文件常量</h4><h4 id="9-改进-Aarch64-Intrinsics"><a href="#9-改进-Aarch64-Intrinsics" class="headerlink" title="9.改进 Aarch64 Intrinsics"></a>9.改进 Aarch64 Intrinsics</h4><h4 id="10-删除-Java-EE-和-CORBA-模块"><a href="#10-删除-Java-EE-和-CORBA-模块" class="headerlink" title="10.删除 Java EE 和 CORBA 模块"></a>10.删除 Java EE 和 CORBA 模块</h4><h4 id="11-Curve25519-和-Curve448-算法的密钥协议"><a href="#11-Curve25519-和-Curve448-算法的密钥协议" class="headerlink" title="11.Curve25519 和 Curve448 算法的密钥协议"></a>11.Curve25519 和 Curve448 算法的密钥协议</h4><h4 id="12-Flight-Recorder-飞行记录器"><a href="#12-Flight-Recorder-飞行记录器" class="headerlink" title="12.Flight Recorder(飞行记录器)"></a>12.Flight Recorder(飞行记录器)</h4><h4 id="13-haCha20-和-Poly1305-加密算法支持"><a href="#13-haCha20-和-Poly1305-加密算法支持" class="headerlink" title="13.haCha20 和 Poly1305 加密算法支持"></a>13.haCha20 和 Poly1305 加密算法支持</h4><h4 id="14-Launch-Single-File-Source-Code-Programs（启动单一文件的源代码程序）"><a href="#14-Launch-Single-File-Source-Code-Programs（启动单一文件的源代码程序）" class="headerlink" title="14.Launch Single-File Source-Code Programs（启动单一文件的源代码程序）"></a>14.Launch Single-File Source-Code Programs（启动单一文件的源代码程序）</h4><h4 id="15-低开销的-Heap-Profiling"><a href="#15-低开销的-Heap-Profiling" class="headerlink" title="15.低开销的 Heap Profiling"></a>15.低开销的 Heap Profiling</h4><h4 id="16-TLS-1-3支持"><a href="#16-TLS-1-3支持" class="headerlink" title="16.TLS 1.3支持"></a>16.TLS 1.3支持</h4><h4 id="17-弃用-Nashorn-JavaScript-引擎"><a href="#17-弃用-Nashorn-JavaScript-引擎" class="headerlink" title="17.弃用 Nashorn JavaScript 引擎"></a>17.弃用 Nashorn JavaScript 引擎</h4><h4 id="18-弃用-Pack200-工具和-API"><a href="#18-弃用-Pack200-工具和-API" class="headerlink" title="18.弃用 Pack200 工具和 API"></a>18.弃用 Pack200 工具和 API</h4><h3 id="jdk12"><a href="#jdk12" class="headerlink" title="jdk12"></a>jdk12</h3><h4 id="1-Switch-Expressions"><a href="#1-Switch-Expressions" class="headerlink" title="1.Switch Expressions"></a>1.Switch Expressions</h4><p>这是一个为开发者准备的特性，我们可以利用具体代码快速了解一下，下面是传统 statement 形式的 switch 语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MONDAY:</span><br><span class="line">        <span class="keyword">case</span> FRIDAY:</span><br><span class="line">        <span class="keyword">case</span> SUNDAY:</span><br><span class="line">            System.out.println(<span class="number">6</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TUESDAY:</span><br><span class="line">            System.out.println(<span class="number">7</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> THURSDAY:</span><br><span class="line">        <span class="keyword">case</span> SATURDAY:</span><br><span class="line">            System.out.println(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WEDNESDAY:</span><br><span class="line">            System.out.println(<span class="number">9</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<p>如果有编码经验，你一定知道，switch 语句如果漏写了一个 break，那么逻辑往往就跑偏了，这种方式既繁琐，又容易出错。如果换成 switch 表达式，Pattern Matching 机制能够自然地保证只有单一路径会被执行，请看下面的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line"><span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">case</span> TUESDAY -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">case</span> THURSDAY, SATURDAY -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">case</span> WEDNESDAY -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>更进一步，下面的表达式，为我们提供了优雅地表达特定场合计算逻辑的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numLetters = <span class="keyword">switch</span> (day) &#123;</span><br><span class="line"><span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; <span class="number">6</span>;</span><br><span class="line"><span class="keyword">case</span> TUESDAY -&gt; <span class="number">7</span>;</span><br><span class="line"><span class="keyword">case</span> THURSDAY, SATURDAY -&gt; <span class="number">8</span>;</span><br><span class="line"><span class="keyword">case</span> WEDNESDAY -&gt; <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>Switch Expressions 或者说起相关的 Pattern Matching 特性，为我们提供了勾勒出了 Java 语法进化的一个趋势，将开发者从复杂繁琐的低层次抽象中逐渐解放出来，以更高层次更优雅的抽象，既降低代码量，又避免意外编程错误的出现，进而提高代码质量和开发效率。</p>
<h4 id="2-Shenandoah-GC"><a href="#2-Shenandoah-GC" class="headerlink" title="2.Shenandoah GC"></a>2.Shenandoah GC</h4><p>新增了一个名为 Shenandoah 的 GC 算法，通过与正在运行的 Java 线程同时进行 evacuation 工作来减少 GC 暂停时间。使用 Shenandoah 的暂停时间与堆大小无关，这意味着无论堆是 200 MB 还是 200 GB，都将具有相同的暂停时间。</p>
<h3 id="JDK13"><a href="#JDK13" class="headerlink" title="JDK13"></a>JDK13</h3><p>JDK13于9月17日正式发布。目前该版本包含的特性已经全部固定，主要包含以下五个：</p>
<p>下面来逐一介绍下这五个重要的特性。</p>
<h4 id="1-Dynamic-CDS-Archives"><a href="#1-Dynamic-CDS-Archives" class="headerlink" title="1.Dynamic CDS Archives"></a>1.Dynamic CDS Archives</h4><p>这一特性是在JEP310：Application Class-Data Sharing基础上扩展而来的，Dynamic CDS Archives中的CDS指的就是Class-Data Sharing。</p>
<p>那么，这个JEP310是个啥东西呢？</p>
<p>我们知道在同一个物理机／虚拟机上启动多个JVM时，如果每个虚拟机都单独装载自己需要的所有类，启动成本和内存占用是比较高的。所以Java团队引入了CDS的概念，通过把一些核心类在每个JVM间共享，每个JVM只需要装载自己的应用类，启动时间减少了，另外核心类是共享的，所以JVM的内存占用也减少了。</p>
<p>CDS 只能作用于 Boot Class Loader 加载的类，不能作用于 App Class Loader 或者自定义的 Class Loader 加载的类。</p>
<p>在 Java 10 中，则将 CDS 扩展为 AppCDS，顾名思义，AppCDS 不止能够作用于 Boot Class Loader了，App Class Loader 和自定义的 Class Loader 也都能够起作用，大大加大了 CDS 的适用范围。也就说开发自定义的类也可以装载给多个JVM共享了。</p>
<p>Java 10中包含的JEP310的通过跨不同Java进程共享公共类元数据来减少了内存占用和改进了启动时间。</p>
<p>但是，JEP310中，使用AppCDS的过程还是比较复杂的，需要有三个步骤：</p>
<p>这一次的JDK 13中的JEP 350 ，在JEP310的基础上，又做了一些扩展。允许在Java应用程序执行结束时动态归档类，归档类将包括默认的基础层 CDS（class data-sharing）存档中不存在的所有已加载的应用程序类和库类。</p>
<p>也就是说，在Java 13中再使用AppCDS的时候，就不在需要这么复杂了。</p>
<h4 id="2-ZGC-Uncommit-Unused-Memory"><a href="#2-ZGC-Uncommit-Unused-Memory" class="headerlink" title="2.ZGC: Uncommit Unused Memory"></a>2.ZGC: Uncommit Unused Memory</h4><p>在讨论这个问题之前，想先问一个问题，JVM的GC释放的内存会还给操作系统吗？</p>
<p>GC后的内存如何处置，其实是取决于不同的垃圾回收器的。因为把内存还给OS，意味着要调整JVM的堆大小，这个过程是比较耗费资源的。</p>
<p>在JDK 11中，Java引入了ZGC，这是一款可伸缩的低延迟垃圾收集器，但是当时只是实验性的。并且，ZGC释放的内存是不会还给操作系统的。</p>
<p>而在Java 13中，JEP 351再次对ZGC做了增强，本次 ZGC 可以将未使用的堆内存返回给操作系统。之所以引入这个特性，是因为如今有很多场景中内存是比较昂贵的资源，在以下情况中，将内存还给操作系统还是很有必要的：</p>
<p>1、那些需要根据使用量付费的容器</p>
<p>2、应用程序可能长时间处于空闲状态并与许多其他应用程序共享或竞争资源的环境。</p>
<p>3、应用程序在执行期间可能有非常不同的堆空间需求。例如，启动期间所需的堆可能大于稍后在稳定状态执行期间所需的堆。</p>
<h4 id="3-Reimplement-the-Legacy-Socket-API"><a href="#3-Reimplement-the-Legacy-Socket-API" class="headerlink" title="3.Reimplement the Legacy Socket API"></a>3.Reimplement the Legacy Socket API</h4><p>使用易于维护和调试的更简单、更现代的实现替换 java.net.Socket 和 java.net.ServerSocket API。</p>
<p>java.net.Socket和java.net.ServerSocket的实现非常古老，这个JEP为它们引入了一个现代的实现。现代实现是Java 13中的默认实现，但是旧的实现还没有删除，可以通过设置系统属性jdk.net.usePlainSocketImpl来使用它们。</p>
<p>运行一个实例化Socket和ServerSocket的类将显示这个调试输出。这是默认的(新的).</p>
<p>上面输出的sun.nio.ch.NioSocketImpl就是新提供的实现。</p>
<p>如果使用旧的实现也是可以的（指定参数jdk.net.usePlainSocketImpl）：</p>
<p>上面的结果中，旧的实现java.net.PlainSocketImpl被用到了。</p>
<h4 id="4-Switch-Expressions-Preview"><a href="#4-Switch-Expressions-Preview" class="headerlink" title="4.Switch Expressions (Preview)"></a>4.Switch Expressions (Preview)</h4><p>在JDK 12中引入了Switch表达式作为预览特性。JEP 354修改了这个特性，它引入了yield语句，用于返回值。这意味着，switch表达式(返回值)应该使用yield, switch语句(不返回值)应该使用break。</p>
<p>在以前，我们想要在switch中返回内容，还是比较麻烦的，一般语法如下：</p>
<p>在JDK13中使用以下语法：</p>
<p>或者</p>
<p>在这之后，switch中就多了一个关键字用于跳出switch块了，那就是yield，他用于返回一个值。和return的区别在于：return会直接跳出当前循环或者方法，而yield只会跳出当前switch块。</p>
<h4 id="5-Text-Blocks-Preview"><a href="#5-Text-Blocks-Preview" class="headerlink" title="5.Text Blocks (Preview)"></a>5.Text Blocks (Preview)</h4><p>在JDK 12中引入了Raw String Literals特性，但在发布之前就放弃了。这个JEP在引入多行字符串文字（text block）在意义上是类似的。</p>
<p>text block，文本块，是一个多行字符串文字，它避免了对大多数转义序列的需要，以可预测的方式自动格式化字符串，并在需要时让开发人员控制格式。</p>
<p>我们以前从外部copy一段文本串到Java中，会被自动转义，如有一段以下字符串：</p>
<p>将其复制到Java的字符串中，会展示成以下内容：</p>
<p>使用“”“作为文本块的开始符合结束符，在其中就可以放置多行的字符串，不需要进行任何转义。看起来就十分清爽了。</p>
<p>如常见的SQL语句：</p>
<p>看起来就比较直观，清爽了。</p>
<p>JDK13中包含的5个特性，能够改变开发者的编码风格的主要有Text Blocks和Switch Expressions两个新特性，但是这两个特性还处于预览阶段。</p>
<p>而且，JDK13并不是LTS（长期支持）版本，如果你正在使用Java 8（LTS）或者Java 11（LTS），暂时可以不必升级到Java 13.</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-java基础/java基础-代理模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/03/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"
    >java基础-代理模式</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/03/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-07-03T14:36:00.000Z" itemprop="datePublished">2020-07-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1.代理模式"></a>1.代理模式</h1><blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。（结构型模式）</p>
</blockquote>
<p>#2.优缺点<br><strong>优点:</strong></p>
<ol>
<li>代理模式能将代理对象与真实对象被调用的目标对象分离。</li>
<li>一定程度上降低了系统的耦合度，扩展性好。</li>
<li>保护目标对象。</li>
<li>增强目标对象。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>代理模式会造成系统设计中类的数目的增加。</li>
<li>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢</li>
<li>增加了系统的复杂度。</li>
</ol>
<p>#3.代理模式分类</p>
<ul>
<li>静态代理</li>
<li>JDK动态代理</li>
<li>CGLIB动态代理</li>
</ul>
<h1 id="4-简单实现例子"><a href="#4-简单实现例子" class="headerlink" title="4.简单实现例子"></a>4.简单实现例子</h1><blockquote>
<p><strong>静态代理</strong></p>
</blockquote>
<p>用歌手，经纪人的例子举例：<br><img src="https://upload-images.jianshu.io/upload_images/19382524-ccafaefa877cfd07.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="静态代理.jpg"></p>
<p>静态代理必须实现同一个接口</p>
<p><strong>代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public interface Sing &#123;</span><br><span class="line">    void singSongs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;歌手</span><br><span class="line">public class Singer implements Sing &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void singSongs() &#123;</span><br><span class="line">        System.out.println(&quot;singer can sing songs&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;经纪人</span><br><span class="line">public class Agent implements Sing &#123;</span><br><span class="line">    private Sing sing &#x3D; null;</span><br><span class="line">    @Override</span><br><span class="line">    public void singSongs() &#123;</span><br><span class="line">        sing.singSongs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Agent(Sing sing) &#123;</span><br><span class="line">        this.sing &#x3D; sing;</span><br><span class="line">        System.out.println(&quot;代理人接收到唱歌邀请&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;判断是否能去，金钱，时间安排，对歌手有没影响&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;邀请单位给出评价，相约下次合作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>演出开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Performance &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singer singer &#x3D; new Singer();</span><br><span class="line">        Agent agent &#x3D; new Agent(singer);</span><br><span class="line"></span><br><span class="line">        agent.before();</span><br><span class="line">        agent.singSongs();</span><br><span class="line">        agent.after();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>result</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">代理人接收到唱歌邀请</span><br><span class="line">判断是否能去，金钱，时间安排，对歌手有没影响</span><br><span class="line">singer can sing songs</span><br><span class="line">邀请单位给出评价，相约下次合作</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong><br>从上面的代码中可以看出静态代理类,将代码写死了,如果需要这个代理类代理多个类那么就需要为每个类编写代码,这样做不利于程序的扩展</p>
<blockquote>
<p><strong>JDK动态代理</strong></p>
</blockquote>
<p><code>JDKAgent</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class JDKAgent implements InvocationHandler &#123;</span><br><span class="line"></span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public JDKAgent(Object target) &#123;</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object creatAgent()&#123;</span><br><span class="line">        &#x2F;&#x2F; 1.得到目标对象的类加载器</span><br><span class="line">        ClassLoader classLoader &#x3D; target.getClass().getClassLoader();</span><br><span class="line">        &#x2F;&#x2F; 2.得到目标对象的实现接口</span><br><span class="line">        Class&lt;?&gt;[] interfaces &#x3D; target.getClass().getInterfaces();</span><br><span class="line">        &#x2F;&#x2F; 3.第三个参数需要一个实现invocationHandler接口的对象</span><br><span class="line">        Object newProxyInstance &#x3D; Proxy.newProxyInstance(classLoader, interfaces, this);</span><br><span class="line">        return newProxyInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 第一个参数:代理对象.一般不使用</span><br><span class="line">    &#x2F;&#x2F; 第二个参数:需要增强的方法</span><br><span class="line">    &#x2F;&#x2F; 第三个参数:方法中的参数</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        before();</span><br><span class="line">        Object invoke &#x3D; method.invoke(target, args);</span><br><span class="line">        after();</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void before()&#123;</span><br><span class="line">        System.out.println(&quot;判断此次演出准备工作是否到位&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;演出是否完美收官&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>测试类</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class JDKDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singer singer &#x3D; new Singer();</span><br><span class="line">        JDKAgent jdkAgent &#x3D; new JDKAgent(singer);</span><br><span class="line"></span><br><span class="line">        Sing sing &#x3D; (Sing)jdkAgent.creatAgent();</span><br><span class="line">        sing.singSongs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>result</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">判断此次演出准备工作是否到位</span><br><span class="line">singer can sing songs</span><br><span class="line">演出是否完美收官</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<ul>
<li><p>Interface：对于JDK Proxy,业务类是需要一个Interface的，这是一个缺陷；</p>
</li>
<li><p> Proxy：Proxy类是动态产生的，这个类在调用Proxy.newProxyInstance()方法之后，产生一个Proxy类的实力。实际上，这个Proxy类也是存在的，不仅仅是类的实例，这个Proxy类可以保存在硬盘上；</p>
</li>
<li><p>Method：对于业务委托类的每个方法，现在Proxy类里面都不用静态显示出来</p>
</li>
<li><p>InvocationHandler：这个类在业务委托类执行时，会先调用invoke方法。invoke方法在执行想要的代理操作，可以实现对业务方法的再包装。</p>
</li>
</ul>
<blockquote>
<p><strong>CGLIB动态代理</strong></p>
</blockquote>
<blockquote>
<p>CGLIB(Code Generation Library)是一个开源项目,是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类.如果你要单独使用CGLIB，那么需要导入cglib的jar包还需要一个asm相关jar包，但是spring框架的spring-core.jar包中已经集成了cglib与asm.<br>CGLib是针对类来实现代理的，他的原理是对指定的目标生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理.</p>
</blockquote>
<p><strong>注意:</strong><br>jdk的动态代理只可以为接口去完成操作，而cglib它可以为没有实现接口的类去做代理，也可以为实现接口的类去做代理</p>
<p><code>Dancer</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Dancer &#123;</span><br><span class="line">    public void dance()&#123;</span><br><span class="line">        System.out.println(&quot;dancer can dance&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>代理类</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class CglibAgent implements MethodInterceptor &#123;</span><br><span class="line">    &#x2F;&#x2F;得到目标对象</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用构造方法传递目标对象</span><br><span class="line">    public CglibAgent(Object target) &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.target &#x3D; target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建代理对象</span><br><span class="line">    public Object createProxy()&#123;</span><br><span class="line">        &#x2F;&#x2F;1.创建Enhancer</span><br><span class="line">        Enhancer enhancer &#x3D; new Enhancer();</span><br><span class="line">        &#x2F;&#x2F;2.传递目标对象的class</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        &#x2F;&#x2F;3.设置回调操作</span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line"></span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    &#x2F;&#x2F;参数一:代理对象;参数二:需要增强的方法;参数三:需要增强方法的参数;参数四:需要增强的方法的代理</span><br><span class="line">    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F; 增强前</span><br><span class="line">        System.out.println(&quot;这是增强方法前......&quot;);</span><br><span class="line">        Object invoke &#x3D; methodProxy.invoke(target, args);</span><br><span class="line">        &#x2F;&#x2F; 增强后</span><br><span class="line">        System.out.println(&quot;这是增强方法后......&quot;);</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>测试</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class CglibDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Singer singer &#x3D; new Singer();</span><br><span class="line">        CglibAgent cglibAgent &#x3D; new CglibAgent(singer);</span><br><span class="line">        Sing sing &#x3D; (Sing)cglibAgent.createProxy();</span><br><span class="line">        sing.singSongs();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------separator--------&quot;);</span><br><span class="line"></span><br><span class="line">        Dancer dancer &#x3D; new Dancer();</span><br><span class="line">        CglibAgent dancerAgent &#x3D; new CglibAgent(dancer);</span><br><span class="line">        Dancer proxy &#x3D; (Dancer) dancerAgent.createProxy();</span><br><span class="line">        proxy.dance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>result</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这是增强方法前......</span><br><span class="line">singer can sing songs</span><br><span class="line">这是增强方法后......</span><br><span class="line">--------separator--------</span><br><span class="line">这是增强方法前......</span><br><span class="line">dancer can dance</span><br><span class="line">这是增强方法后......</span><br></pre></td></tr></table></figure>


<p><strong>总结</strong><br>|方式|优点|缺点|<br>|—|—|–|<br>|静态代理|简单，需实现统一接口|扩展性差，性能|<br>|JDK动态代理|耦合低，需实现统一接口|性能|<br>|CGLIB动态代理|不需实现统一接口，代理类不能是final|性能|</p>
<p>代码 <a target="_blank" rel="noopener" href="https://gitee.com/dancer4code/spring-boot-lab/tree/master/proxy-demo">proxy-demo</a></p>
<p>参考<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/happy_write/article/details/81235096">静态代理、JDK动态代理和CGLIB动态代理之间的区别?</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6991491be81a">代理模式</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-java基础/java设计模式-1工厂模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/03/java%E5%9F%BA%E7%A1%80/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"
    >java设计模式-1工厂模式</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/03/java%E5%9F%BA%E7%A1%80/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2020-07-03T14:36:00.000Z" itemprop="datePublished">2020-07-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>#1.什么是工厂模式</p>
<blockquote>
<p>用工厂方法代替了new操作, 将选择实现类, 创建对象统一管理和控制.从而将调用者(Client)与实现类进行解耦.实现了创建者与调用者分离;</p>
</blockquote>
<h1 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2.使用场景"></a>2.使用场景</h1><ul>
<li>JDK中Calendar的getInstance方法;</li>
<li>JDBC中Connection对象的获取;</li>
<li>MyBatis中SqlSessionFactory创建SqlSession;</li>
<li>SpringIoC容器创建并管理Bean对象;</li>
<li>反射Class对象的newInstance;</li>
<li>。。。。。。</li>
</ul>
<p>#3.三种方式</p>
<ul>
<li>静态工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<p>#4.具体用法<br>**<em>静态工厂模式**</em></p>
<blockquote>
<p>静态工厂模式是工厂模式中最简单的一种，他可以用比较简单的方式隐藏创建对象的细节，一般只需要告诉工厂类所需要的类型，工厂类就会返回需要的产品类，而客户端看到的也只是产品的抽象对象(interface)，因此无需关心到底是返回了哪个子类</p>
</blockquote>
<p>例如生产不同产品的例子类图结构如下：<br><img src="https://upload-images.jianshu.io/upload_images/19382524-ebc792482eb45acc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="简单工厂模式1.jpg"></p>
<p>具体代码如下：<br><code>1.定义一个产品接口</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Product &#123;</span><br><span class="line">    void produce();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>2.实现类</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ProductA implements Product&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产出了产品A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductB implements Product&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产出了产品B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ProductC implements Product&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产出了产品C&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class ProductD implements Product&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产出了产品D&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductDefault implements Product&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产出了产品-default&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>3.工厂类</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class ProductFactory &#123;</span><br><span class="line">    public static Product getProduct(String name)&#123;</span><br><span class="line">        switch (name)&#123;</span><br><span class="line">            case &quot;A&quot; :</span><br><span class="line">                return new ProductA();</span><br><span class="line">            case &quot;B&quot;:</span><br><span class="line">                return new ProductB();</span><br><span class="line">            default:</span><br><span class="line">                return new ProductDefault();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>4.测试类</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ProductProduceDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;硬编码</span><br><span class="line">        ProductFactory.getProduct(&quot;A&quot;).produce();</span><br><span class="line">        ProductFactory.getProduct(&quot;B&quot;).produce();</span><br><span class="line">        ProductFactory.getProduct(&quot;ggg&quot;).produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<blockquote>
<p>隐藏了对象创建的细节，将产品的实例化过程放到了工厂中实现。<br>客户端基本不用关心使用的是哪个产品，只需要知道用工厂的那个方法(或传入什么参数)就行了.<br>方便添加新的产品子类，每次只需要修改工厂类传递的类型值就行了。<br>遵循了依赖倒转原则。</p>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<p>适用于产品子类型差不多, 使用的方法名都相同的情况.<br>每添加一个产品子类，都必须在工厂类中添加一个判断分支(或一个方法)，这违背了OCP(开放-封闭原则)。</p>
</blockquote>
<hr>
<p><strong><em>工厂方法模式</em></strong></p>
<blockquote>
<p>由于静态工厂方法模式不满足OCP, 因此就出现了工厂方法模式; 工厂方法模式和静态工厂模式最大的不同在于: 静态工厂模式只有一个(对于一个项目/独立模块)只有一个工厂类, 而工厂方法模式则有一组实现了相同接口的工厂类.</p>
</blockquote>
<p>工厂方法模式就是与静态工厂的差异就是把原来偶合的一个工厂根据业务逻辑分成独立的工厂，这样在增加新的业务时就不需要反复修改同一个工厂类，更符合开闭原则。</p>
<p><strong>代码：</strong><br><code>1.增加抽象工厂接口</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Factory &#123;</span><br><span class="line">    Product getProduct();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>2.每个产品都实现相应工厂</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ProductAFactory implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct() &#123;</span><br><span class="line">        return new ProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductBFactory implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct() &#123;</span><br><span class="line">        return new ProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ProductCFactory implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct() &#123;</span><br><span class="line">        return new ProductC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要增加一个新的产品ProductD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ProductD implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产出了产品D&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需增加一个产品D的工厂类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ProductDFactory implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product getProduct() &#123;</span><br><span class="line">        return new ProductD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>与静态工厂相比似乎实现相应的功能，似乎代码量增加了。但是，相比而言耦合度降低了，更利于程序的扩展。</p>
<p><code>总结</code><br><strong>优点</strong> </p>
<blockquote>
<p>基本与静态工厂模式一致，多的一点优点就是遵循了开放-封闭原则，使得模式的灵活性更强。</p>
</blockquote>
<p><strong>缺点</strong></p>
<blockquote>
<p>与静态工厂模式差不多, 但是增加了类组织的复杂性;</p>
</blockquote>
<blockquote>
<p>虽然根据理论原则, 需要使用工厂方法模式, 但实际上是用静态工厂模式还是工厂方法模式还是更具实际情况考虑。</p>
</blockquote>
<hr>
<p><strong><em>抽象工厂模式</em></strong></p>
<blockquote>
<p>抽象工厂模式: 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定他们具体的类.</p>
</blockquote>
<p>抽象工厂模式与工厂方法模式的区别:<br>抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构. 在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类(如下面的Engine,  Seat).<br>在抽象工厂模式中，提出了产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族(如Engine,  Seat)。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构.</p>
<p><strong>示例:</strong><br>现在我们要生产两款车: 高档(LuxuryCar)与低档(LowCar), 他们分别配有高端引擎(LuxuryEngine),低端引擎(LowEngine),  高端座椅(LuxurySeat)和低端座椅(LowSeat),  下面我们用抽象工厂实现它:<br>LuxuryCarFactory与LowCarFactory分别代表一类产品族的两款产品, 类似于数据库产品族中有MySQL, Oracle, SqlServer</p>
<p><code>Engine</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public interface Engine &#123;</span><br><span class="line"></span><br><span class="line">    void start();</span><br><span class="line"></span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowEngine implements Engine &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;启动慢 ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;转速慢 ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxuryEngine implements Engine &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;启动快 ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;转速快 ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Seat</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface Seat &#123;</span><br><span class="line">    void message();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LowSeat implements Seat &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void message() &#123;</span><br><span class="line">        System.out.println(&quot;不能按摩 ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class LuxurySeat implements Seat &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void message() &#123;</span><br><span class="line">        System.out.println(&quot;可提供按摩 ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>产品族Factory</code></p>
<p><code>Factory</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface CarFactory &#123;</span><br><span class="line"></span><br><span class="line">    Engine createEngine();</span><br><span class="line"></span><br><span class="line">    Seat createSeat();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LuxuryCarFactory</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LuxuryCarFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Engine createEngine() &#123;</span><br><span class="line">        return new LuxuryEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Seat createSeat() &#123;</span><br><span class="line">        return new LuxurySeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>LowCarFactory</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LowCarFactory implements CarFactory &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Engine createEngine() &#123;</span><br><span class="line">        return new LowEngine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Seat createSeat() &#123;</span><br><span class="line">        return new LowSeat();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Client</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class CarTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        CarFactory factory &#x3D; new LowCarFactory();</span><br><span class="line">        Engine engine &#x3D; factory.createEngine();</span><br><span class="line">        engine.start();</span><br><span class="line">        engine.run();</span><br><span class="line">        Seat seat &#x3D; factory.createSeat();</span><br><span class="line">        seat.message();</span><br><span class="line">        System.out.println(&quot;---------------separator--------------&quot;);</span><br><span class="line"></span><br><span class="line">        CarFactory factory2 &#x3D; new LuxuryCarFactory();</span><br><span class="line">        Engine engine2 &#x3D; factory.createEngine();</span><br><span class="line">        engine2.start();</span><br><span class="line">        engine2.run();</span><br><span class="line">        Seat seat2 &#x3D; factory.createSeat();</span><br><span class="line">        seat2.message();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>总结</code></p>
<p><strong>优点</strong> </p>
<blockquote>
<p>封装了产品的创建，使得不需要知道具体是哪种产品，只需要知道是哪个工厂就行了。<br>可以支持不同类型的产品，使得模式灵活性更强。<br>可以非常方便的使用一族中间的不同类型的产品。</p>
</blockquote>
<p><strong>缺点</strong><br>结构太过臃肿，如果产品类型比较多，或者产品族类比较多，就会非常难于管理。<br>每次如果添加一组产品，那么所有的工厂类都必须添加一个方法，这样违背了开放-封闭原则。所以一般适用于产品组合产品族变化不大的情况。</p>
<hr>
<p><strong><em>使用静态工厂优化抽象工厂+反射+配置文件</em></strong></p>
<p>由于抽象工厂模式存在结构臃肿以及改动复杂的缺点(比如我们每次需要构造Car, 都需要进行CarFactory factory = new XxxCarFactory(),而一般一个项目中只会生产一种Car, 如果我们需要更改生产的车的类型, 那么客户端的每一处调用都需要修改), 因此我们可以使用静态工厂对其进行改造, 我们使用CarCreator来统一创建一个产品族不同产品, 这样如果我们的工厂将来更改了产品路线, 改为生产高端车时, 我们仅需改变CAR_TYEP的值就可以了:</p>
<p><code>CarCreator</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class CarCreator &#123;</span><br><span class="line">    private static final String CAR_TYPE &#x3D; &quot;low&quot;;</span><br><span class="line">    private static final String CAR_TYPE_LOW &#x3D; &quot;low&quot;;</span><br><span class="line">    private static final String CAR_TYPE_LUXURY &#x3D; &quot;luxury&quot;;</span><br><span class="line"></span><br><span class="line">    public static Engine createEngine() &#123;</span><br><span class="line">        Engine engine &#x3D; null;</span><br><span class="line">        switch (CAR_TYPE) &#123;</span><br><span class="line">            case CAR_TYPE_LOW:</span><br><span class="line">                engine &#x3D; new LowEngine();</span><br><span class="line">                break;</span><br><span class="line">            case CAR_TYPE_LUXURY:</span><br><span class="line">                engine &#x3D; new LuxuryEngine();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Seat createSeat() &#123;</span><br><span class="line">        Seat seat &#x3D; null;</span><br><span class="line">        switch (CAR_TYPE) &#123;</span><br><span class="line">            case CAR_TYPE_LOW:</span><br><span class="line">                seat &#x3D; new LowSeat();</span><br><span class="line">                break;</span><br><span class="line">            case CAR_TYPE_LUXURY:</span><br><span class="line">                seat &#x3D; new LuxurySeat();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return seat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CarCreatorReflection</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public class CarCreatorReflection &#123;</span><br><span class="line">    private static String packName;</span><br><span class="line">    private static String carType;</span><br><span class="line">    private static String engine;</span><br><span class="line">    private static String seat;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 读取配置文件内容并判断赋值，初始化变量值</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            URL resource &#x3D; Object.class.getResource(&quot;&#x2F;car.json&quot;);</span><br><span class="line">            File file &#x3D; new File(resource.getFile());</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader(new InputStreamReader(new FileInputStream(file), &quot;UTF-8&quot;));</span><br><span class="line">            StringBuffer config &#x3D; new StringBuffer();</span><br><span class="line">            String s &#x3D; null;</span><br><span class="line">            while ((s &#x3D; bufferedReader.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                config.append(s);</span><br><span class="line">            &#125;</span><br><span class="line">            bufferedReader.close();</span><br><span class="line"></span><br><span class="line">            JSONObject jsonObject &#x3D; JSON.parseObject(config.toString());</span><br><span class="line">            packName &#x3D; jsonObject.getString(&quot;packName&quot;);</span><br><span class="line">            carType &#x3D; jsonObject.getString(&quot;carType&quot;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;判断赋值</span><br><span class="line">        switch (carType) &#123;</span><br><span class="line">            case &quot;Low&quot;:</span><br><span class="line">                engine &#x3D; &quot;LowEngine&quot;;</span><br><span class="line">                seat &#x3D; &quot;LowSeat&quot;;</span><br><span class="line">                break;</span><br><span class="line">            case &quot;Luxury&quot;:</span><br><span class="line">                engine &#x3D; &quot;LuxuryEngine&quot;;</span><br><span class="line">                seat &#x3D; &quot;LuxurySeat&quot;;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                engine &#x3D; &quot;LuxuryEngine&quot;;</span><br><span class="line">                seat &#x3D; &quot;LuxurySeat&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Engine createEngine() throws Exception &#123;</span><br><span class="line">        String className &#x3D; packName + &quot;.&quot; + engine;</span><br><span class="line">        return (Engine) Class.forName(className).newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Seat createSeat() throws Exception &#123;</span><br><span class="line">        String className &#x3D; packName + &quot;.&quot; + seat;</span><br><span class="line">        return (Seat) Class.forName(className).newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>配置文件car.json</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;packName&quot;: &quot;com.d4c.demo.factory.abstract1&quot;,</span><br><span class="line">  &quot;carType&quot;: &quot;Luxury&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>测试</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class CarTest2 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        Engine engine &#x3D; CarCreator.createEngine();</span><br><span class="line">        engine.run();</span><br><span class="line">        engine.start();</span><br><span class="line">        Seat seat &#x3D; CarCreator.createSeat();</span><br><span class="line">        seat.message();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;-----------separator-----------&quot;);</span><br><span class="line"></span><br><span class="line">        Engine engine2 &#x3D; CarCreatorReflection.createEngine();</span><br><span class="line">        engine2.run();</span><br><span class="line">        engine2.start();</span><br><span class="line">        Seat seat2 &#x3D; CarCreatorReflection.createSeat();</span><br><span class="line">        seat2.message();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>result</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">转速慢 ...</span><br><span class="line">启动慢 ...</span><br><span class="line">不能按摩 ...</span><br><span class="line">-----------separator-----------</span><br><span class="line">转速快 ...</span><br><span class="line">启动快 ...</span><br><span class="line">可提供按摩 ...</span><br></pre></td></tr></table></figure>

<p><code>总结</code><br>|分类    |说明|<br>|–|–|<br>|静态工厂模式    |用来生成同一等级结构中的任意产品, 对于增加新的产品, 需要修改已有代码<br>|工厂方法模式|    用来生成同一等级结构的固定产品, 支持增加任意产品;<br>|抽象工厂模式    |用来生成不同产品族的全部产品, 对于增加新的产品无能为力;</p>
<p><strong>源码</strong>  <a target="_blank" rel="noopener" href="https://gitee.com/dancer4code/spring-boot-lab/tree/master/factory-demo">gitee</a></p>
<p>文章大部分参考(转载)<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zjf280441589/article/details/50282773">工厂模式</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e55fbddc071c">简单工厂模式（SimpleFactoryPattern）- 最易懂的设计模式解</a><br><a target="_blank" rel="noopener" href="https://blog.51cto.com/zero01/2067822">设计模式之工厂方法模式</a><br><a target="_blank" rel="noopener" href="https://blog.51cto.com/zero01/2070033">设计模式之抽象工厂模式</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/cxjchen/p/3143633.html">三种工厂模式的分析以及C++实现</a> <br><a target="_blank" rel="noopener" href="http://book.douban.com/subject/2334288/">大话设计模式</a> <br><a target="_blank" rel="noopener" href="http://www.bjsxt.com/2014/down_0425/34.html">高淇讲设计模式</a> <br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3919839.html">设计模式之六大原则</a> <br> <a target="_blank" rel="noopener" href="http://blog.csdn.net/zhengzhb/article/details/7359385">23种设计模式(3) - 抽象工厂模式</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-java基础/java基础-java反射"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/01/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80-java%E5%8F%8D%E5%B0%84/"
    >java基础-java反射</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/07/01/java%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80-java%E5%8F%8D%E5%B0%84/" class="article-date">
  <time datetime="2020-07-01T14:36:00.000Z" itemprop="datePublished">2020-07-01</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h1><blockquote>
<p>JAVA反射机制是在运行状态中，对于任意一个实体类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
</blockquote>
<h1 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h1><blockquote>
<p>反射机制(Reflection)是Java提供的一项较为高级的功能，它提供了一种动态功能，而此功能的体现在于通过反射机制相关的API就可以获取任何Java类的包括属性、方法、构造器、修饰符等信息。元素不必在JⅧ运行时进行确定，反射可以使得它们在运行时动态地进行创建或调用。反射技术在中间件领域应用得较多。</p>
</blockquote>
<p>#3. 反射相关的一些类<br><code>java.lang.Class</code> 类和接口<br><code>java.lang.reflect.Field</code> 类的成员变量<br><code>java.lang.reflect.Constructor</code> 类的构造方法<br><code>java.lang.reflect.Method</code> 类的方法</p>
<hr>
<p><strong>获取Class对象三种方式</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方式一 通过对象获取</span><br><span class="line">Person person &#x3D; new Person();</span><br><span class="line">Class personClass1 &#x3D; person.getClass();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方式二 通过类名获取</span><br><span class="line">Class personClass2 &#x3D; Person.class;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;方式三 通过类名的全限定名字符串获取</span><br><span class="line">Class personClass3 &#x3D; Class.forName(&quot;com.d4c.reflection.demo.Person&quot;);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><ul>
<li>  <strong>获得类相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>asSubclass(Class<U> clazz)</td>
<td>把传递的类的对象转换成代表其子类的对象</td>
</tr>
<tr>
<td>Cast</td>
<td>把对象转换成代表类或是接口的对象</td>
</tr>
<tr>
<td>getClassLoader()</td>
<td>获得类的加载器</td>
</tr>
<tr>
<td>getClasses()</td>
<td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td>
</tr>
<tr>
<td>getDeclaredClasses()</td>
<td>返回一个数组，数组中包含该类中所有类和接口类的对象</td>
</tr>
<tr>
<td>forName(String className)</td>
<td>根据类名返回类的对象</td>
</tr>
<tr>
<td>getName()</td>
<td>获得类的完整路径名字</td>
</tr>
<tr>
<td>newInstance()</td>
<td>创建类的实例</td>
</tr>
<tr>
<td>getPackage()</td>
<td>获得类的包</td>
</tr>
<tr>
<td>getSimpleName()</td>
<td>获得类的名字</td>
</tr>
<tr>
<td>getSuperclass()</td>
<td>获得当前类继承的父类的名字</td>
</tr>
<tr>
<td>getInterfaces()</td>
<td>获得当前类实现的类或是接口</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>获得类中属性相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>getField(String name)</td>
<td>获得某个公有的属性对象</td>
</tr>
<tr>
<td>getFields()</td>
<td>获得所有公有的属性对象</td>
</tr>
<tr>
<td>getDeclaredField(String name)</td>
<td>获得某个属性对象</td>
</tr>
<tr>
<td>getDeclaredFields()</td>
<td>获得所有属性对象</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>获得类中注解相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>getAnnotation(Class<A> annotationClass)</td>
<td>返回该类中与参数类型匹配的公有注解对象</td>
</tr>
<tr>
<td>getAnnotations()</td>
<td>返回该类所有的公有注解对象</td>
</tr>
<tr>
<td>getDeclaredAnnotation(Class<A> annotationClass)</td>
<td>返回该类中与参数类型匹配的所有注解对象</td>
</tr>
<tr>
<td>getDeclaredAnnotations()</td>
<td>返回该类所有的注解对象</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>获得类中构造器相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>getConstructor(Class…&lt;?&gt; parameterTypes)</td>
<td>获得该类中与参数类型匹配的公有构造方法</td>
</tr>
<tr>
<td>getConstructors()</td>
<td>获得该类的所有公有构造方法</td>
</tr>
<tr>
<td>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td>
<td>获得该类中与参数类型匹配的构造方法</td>
</tr>
<tr>
<td>getDeclaredConstructors()</td>
<td>获得该类所有构造方法</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>获得类中方法相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>getMethod(String name, Class…&lt;?&gt; parameterTypes)</td>
<td>获得该类某个公有的方法</td>
</tr>
<tr>
<td>getMethods()</td>
<td>获得该类所有公有的方法</td>
</tr>
<tr>
<td>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td>
<td>获得该类某个方法</td>
</tr>
<tr>
<td>getDeclaredMethods()</td>
<td>获得该类所有方法</td>
</tr>
</tbody></table>
<ul>
<li>  <strong>类中其他重要的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>isAnnotation()</td>
<td>如果是注解类型则返回true</td>
</tr>
<tr>
<td>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>
<td>如果是指定类型注解类型则返回true</td>
</tr>
<tr>
<td>isAnonymousClass()</td>
<td>如果是匿名类则返回true</td>
</tr>
<tr>
<td>isArray()</td>
<td>如果是一个数组类则返回true</td>
</tr>
<tr>
<td>isEnum()</td>
<td>如果是枚举类则返回true</td>
</tr>
<tr>
<td>isInstance(Object obj)</td>
<td>如果obj是该类的实例则返回true</td>
</tr>
<tr>
<td>isInterface()</td>
<td>如果是接口类则返回true</td>
</tr>
<tr>
<td>isLocalClass()</td>
<td>如果是局部类则返回true</td>
</tr>
<tr>
<td>isMemberClass()</td>
<td>如果是内部类则返回true</td>
</tr>
</tbody></table>
<h1 id="Field类"><a href="#Field类" class="headerlink" title="Field类"></a>Field类</h1><p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/java/lang/reflect/Field">Field</a>代表类的成员变量（成员变量也称为类的属性）。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>equals(Object obj)</td>
<td>属性与obj相等则返回true</td>
</tr>
<tr>
<td>get(Object obj)</td>
<td>获得obj中对应的属性值</td>
</tr>
<tr>
<td>set(Object obj, Object value)</td>
<td>设置obj中对应属性值</td>
</tr>
</tbody></table>
<h1 id="Method类"><a href="#Method类" class="headerlink" title="Method类"></a>Method类</h1><p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/java/lang/reflect/Method">Method</a>代表类的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>invoke(Object obj, Object… args)</td>
<td>传递object对象及参数调用该对象对应的方法</td>
</tr>
</tbody></table>
<h1 id="Constructor类"><a href="#Constructor类" class="headerlink" title="Constructor类"></a>Constructor类</h1><p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/java/lang/reflect/Constructor">Constructor</a>代表类的构造方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>newInstance(Object… initargs)</td>
<td>根据传递的参数创建类的对象</td>
</tr>
</tbody></table>
<h1 id="4-优点"><a href="#4-优点" class="headerlink" title="4. 优点"></a>4. 优点</h1><p>灵活性高。因为反射属于动态编译，即只有到运行时才动态创建 &amp;获取对象实例。</p>
<p>编译方式说明：</p>
<p>静态编译：在编译时确定类型 &amp; 绑定对象。如常见的使用new关键字创建对象<br>动态编译：运行时确定类型 &amp; 绑定对象。动态编译体现了Java的灵活性、多态特性 &amp; 降低类之间的藕合性</p>
<h1 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5. 缺点"></a>5. 缺点</h1><p>执行效率低<br>因为反射的操作 主要通过JVM执行，所以时间成本会 高于 直接执行相同操作<br>因为接口的通用性，Java的invoke方法是传object和object[]数组的。基本类型参数需要装箱和拆箱，产生大量额外的对象和内存开销，频繁促发GC。<br>编译器难以对动态调用的代码提前做优化，比如方法内联。<br>反射需要按名检索类和方法，有一定的时间开销。<br>容易破坏类结构<br>因为反射操作饶过了源码，容易干扰类原有的内部逻辑#</p>
<h1 id="6-应用场景"><a href="#6-应用场景" class="headerlink" title="6. 应用场景"></a>6. 应用场景</h1><p>动态获取 类文件结构信息（如变量、方法等） &amp; 调用对象的方法<br>常用的需求场景有：动态代理、工厂模式优化、Java JDBC数据库操作等</p>
<p>#7.访问权限问题<br>反射机制的默认行为受限于Java的访问控制，无法访问（ private ）私有的方法、字段。Java安全机制只允许查看任意对象有哪些域，而不允许读它们的值，若强制读取，将抛出异常。</p>
<p><strong>解决方法</strong><br>脱离Java程序中安全管理器的控制、屏蔽Java语言的访问检查，从而脱离访问控制<br><strong>具体实现手段</strong>：使用Field类、Method类 &amp; Constructor类对象的setAccessible()</p>
<ul>
<li><p><code>void setAccessible(boolean flag)   </code><br>作用：为反射对象设置可访问标志<br>规则：flag = true时 ，表示已屏蔽Java语言的访问检查，使得可以访问 &amp; 修改对象的私有属性</p>
</li>
<li><p>  <code>boolean isAccessible()  </code><br>返回反射对象的可访问标志的值</p>
</li>
<li><p><code>static void setAccessible(AccessibleObject[] array, boolean flag)</code><br>设置对象数组可访问标志</p>
</li>
</ul>
<p><code>例子：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.d4c.reflection.demo;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Created with IntelliJ IDEA.</span><br><span class="line"> * @author: liangqing.zhao(zlq)</span><br><span class="line"> * @date: 2019&#x2F;10&#x2F;12 22:35</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;方式一 通过对象获取</span><br><span class="line">        Person person &#x3D; new Person();</span><br><span class="line">        Class personClass1 &#x3D; person.getClass();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;方式二 通过类名获取</span><br><span class="line">        Class personClass2 &#x3D; Person.class;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;方式三 通过类名的全限定名字符串获取</span><br><span class="line">        Class personClass3 &#x3D; Class.forName(&quot;com.d4c.reflection.demo.Person&quot;);</span><br><span class="line"></span><br><span class="line">        Class studentClass &#x3D; Class.forName(&quot;com.d4c.reflection.demo.Student&quot;);</span><br><span class="line">        Student student &#x3D; new Student(&quot;zlq&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;getFields 能够获取public修饰的field和父类中public修饰的field</span><br><span class="line">        Field[] fields &#x3D; studentClass.getFields();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            System.out.println(&quot;field.getName() &#x3D; &quot; + field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;--------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;getDeclaredFields 能够获取类中所有的field，但父类中的field获取不了</span><br><span class="line">        Field[] declaredfields &#x3D; studentClass.getDeclaredFields();</span><br><span class="line">        for (Field declaredfield : declaredfields) &#123;</span><br><span class="line">            System.out.println(&quot;declaredfield.getName() &#x3D; &quot; + declaredfield.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;--------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        Field age &#x3D; personClass3.getDeclaredField(&quot;age&quot;);</span><br><span class="line">        &#x2F;&#x2F;为反射对象设置可访问标志,使得可以访问 &amp; 修改对象的私有属性</span><br><span class="line">        age.setAccessible(true);</span><br><span class="line">        System.out.println(&quot;before age:&quot; + age.get(person));</span><br><span class="line">        age.set(person, 100);</span><br><span class="line">        System.out.println(&quot;after age:&quot; + age.get(person));</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;--------------------------------------&quot;);</span><br><span class="line"></span><br><span class="line">        Field[] declaredFields &#x3D; studentClass.getDeclaredFields();</span><br><span class="line">        &#x2F;&#x2F;批量给访问权限</span><br><span class="line">        AccessibleObject.setAccessible(declaredFields, true);</span><br><span class="line">        </span><br><span class="line">        for (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(&quot;declaredField.get(student) &#x3D; &quot; + declaredField.get(student));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="8-利用反射获取和设置值"><a href="#8-利用反射获取和设置值" class="headerlink" title="8 利用反射获取和设置值"></a>8 利用反射获取和设置值</h1><ul>
<li><p>利用反射获取类的属性 &amp; 赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.d4c.reflection.demo;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @Created with IntelliJ IDEA.</span><br><span class="line"> * @author: liangqing.zhao(zlq)</span><br><span class="line"> * @date: 2019&#x2F;10&#x2F;12 22:20</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">public class PersonDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F; 获取Person类的Class对象</span><br><span class="line">        Class personClass &#x3D; Person.class;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过Class对象创建Person类的对象</span><br><span class="line">        Object person &#x3D; personClass.newInstance();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 通过Class对象获取Person类的nage属性</span><br><span class="line">        Field field &#x3D; personClass.getDeclaredField(&quot;age&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置私有访问权限</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 对新创建的person对象设置age值</span><br><span class="line">        field.set(person, 99);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取新创建person对象的的age属性 &amp; 输出</span><br><span class="line">        System.out.println(field.get(person));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用反射调用类的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  获取Person类的Class对象</span><br><span class="line">Class personClass &#x3D; Person.class;</span><br><span class="line">&#x2F;&#x2F;通过Class对象获取Constructor类对象，从而调用无参构造方法</span><br><span class="line">&#x2F;&#x2F;构造函数的调用实际上是在newInstance()，而不是在getConstructor()中调用</span><br><span class="line">Object obj1 &#x3D; personClass.getConstructor().newInstance();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过Class对象获取Constructor类对象（传入参数类型），从而调用有参构造方法</span><br><span class="line">Object obj2 &#x3D; personClass.getConstructor(String.class).newInstance(&quot;Carson&quot;);</span><br><span class="line"></span><br><span class="line">Object obj3 &#x3D; personClass.getConstructor(Integer.class, String.class, String.class).newInstance(99, &quot;zlq&quot;, &quot;hello world&quot;);</span><br></pre></td></tr></table></figure></li>
<li><p>利用反射调用类对象的方法</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  获取Person类的Class对象</span><br><span class="line">Class personClass3 &#x3D; Person.class;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过Class对象创建Person类的对象</span><br><span class="line">Object  person3 &#x3D; personClass3.newInstance();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过Class对象获取方法getSay的Method对象:需传入方法名</span><br><span class="line">Method getSayMethod &#x3D; personClass3.getMethod(&quot;getSay&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过Method对象调用getSay()：需传入创建的实例</span><br><span class="line">getSayMethod.invoke(person3);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过Class对象获取方法setSay 的Method对象:需传入方法名 &amp; 参数类型</span><br><span class="line">Method setSayMethod &#x3D; personClass3.getMethod(&quot;setSay&quot;,String.class);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过Method对象调用setSay 需传入创建的实例 &amp; 参数值</span><br><span class="line">setSayMethod.invoke(person3,&quot;oop&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.qiji.tech/archives/4374">认识反射机制（Reflection）</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/mengdd/archive/2013/01/26/2877972.html">Java 反射机制</a><br><a target="_blank" rel="noopener" href="http://blog.csdn.net/ljphhj/article/details/12858767">一个例子让你了解Java反射机制</a><br><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cnblogs.com/crazypebble/archive/2011/04/13/2014582.html">Java反射机制的原理及在Android下的简单应用</a><br><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://zlb1986.iteye.com/blog/937781">java中的反射机制</a><br><a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://efany.github.io/2016/04/02/Android%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/">Android注解与反射机制</a><br><a target="_blank" rel="noopener" href="https://developer.android.google.cn/reference/java/lang/reflect/Method?hl=zh-cn">java.lang.reflect.Method</a></p>
<hr>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/356e1d7a9d11">Java反射：这是一份全面 &amp; 详细的 Java反射机制 学习指南</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9be58ee20dee">Java高级特性——反射</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/607ff4e79a13">Java反射完全解析</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jiangzhaowei/p/9364330.html">Java反射机制的适用场景及其利与弊 </a><br> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/vielat/p/10246596.html">Java各种反射性能对比</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yonyong/p/9429079.html">深入解析Java反射</a><br><a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1619604957177623053&wfr=spider&for=pc">Java编程中基础反射详细解析</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/a745233700/article/details/82893076">Java基础篇：反射机制详解</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-java-web/彻底搞定乱码-自定义过滤器（filter）-3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/04/java-web/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9A%E4%B9%B1%E7%A0%81-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88filter%EF%BC%89-3/"
    >彻底搞定乱码-自定义过滤器（filter）-3</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/04/java-web/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9A%E4%B9%B1%E7%A0%81-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88filter%EF%BC%89-3/" class="article-date">
  <time datetime="2020-06-04T14:36:00.000Z" itemprop="datePublished">2020-06-04</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>彻底解决get/post中文乱码</strong></p>
<h1 id="1-包装模式过滤器"><a href="#1-包装模式过滤器" class="headerlink" title="1.包装模式过滤器"></a>1.包装模式过滤器</h1><ul>
<li><p>spring boot 中使用@Component 或者@Configuration</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">package com.dancer4code.actuator.filter;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.annotation.WebFilter;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * User: liangqing.zhao(zlq)</span><br><span class="line"> * Date: 2019&#x2F;10&#x2F;4 19:45</span><br><span class="line"> * Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;@Component</span><br><span class="line">&#x2F;&#x2F;@WebFilter</span><br><span class="line">&#x2F;&#x2F;@Configuration</span><br><span class="line">&#x2F;&#x2F;@Order(value &#x3D; 15)</span><br><span class="line">public class MyCharacterEncodingFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest,</span><br><span class="line">                         ServletResponse servletResponse, FilterChain filterChain)</span><br><span class="line">            throws IOException, ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;----------------MyCharacterEncordingFilter------doFilter-----------------&quot;);</span><br><span class="line">        HttpServletRequest request &#x3D; (HttpServletRequest) servletRequest;</span><br><span class="line">        HttpServletResponse response &#x3D; (HttpServletResponse) servletResponse;</span><br><span class="line">        request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        response.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br><span class="line">        filterChain.doFilter(new MyRequest(request), response);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 1.写一个类实现与被增强对象相同的接口</span><br><span class="line">     * 2.定义一个变量，记住被增强的对象</span><br><span class="line">     * 3.定义一个构造方法，接受被增强对象</span><br><span class="line">     * 4.覆盖想增强的方法</span><br><span class="line">     * 5.对于不想增强的方法，直接调用被增强对象（目标对象）的方法</span><br><span class="line">     *&#x2F;</span><br><span class="line">    class MyRequest extends HttpServletRequestWrapper &#123;</span><br><span class="line">        private HttpServletRequest request;</span><br><span class="line"></span><br><span class="line">        public MyRequest(HttpServletRequest request) &#123;</span><br><span class="line">            super(request);</span><br><span class="line">            this.request &#x3D; request;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String getParameter(String name) &#123;</span><br><span class="line">            String value &#x3D; this.request.getParameter(name);</span><br><span class="line">            if (!request.getMethod().equalsIgnoreCase(&quot;get&quot;)) &#123;</span><br><span class="line">                return value;</span><br><span class="line">            &#125;</span><br><span class="line">            if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            try &#123;</span><br><span class="line">                return new String(value.getBytes(&quot;UTF-8&quot;),</span><br><span class="line">                        request.getCharacterEncoding());</span><br><span class="line"></span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                throw new RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;---MyCharacterEncordingFilter-----init-------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;---MyCharacterEncordingFilter-----destroy-------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>spring boot中使用@WebFilter+@ServletComponentScan(可自定义过滤路径)</p>
</li>
<li><p>spring mvc中使用web.xml中配置（可自定义过滤路径）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;MyCharacterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;com.dancer4code.actuator.filter.MyCharacterEncodingFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">     &lt;filter-name&gt;MyCharacterEncodingFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">     &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>spring mvc中使用@WebFilter注解</p>
</li>
</ul>
<h1 id="2-动态代理"><a href="#2-动态代理" class="headerlink" title="2.动态代理"></a>2.动态代理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package com.dancer4code.actuator.filter;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import javax.servlet.*;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created with IntelliJ IDEA.</span><br><span class="line"> * User: liangqing.zhao(zlq)</span><br><span class="line"> * Date: 2019&#x2F;10&#x2F;5 15:15</span><br><span class="line"> * Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class MyCharacterEncodingProxyFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;----------MyCharacterEncodingProxyFilter---doFilter--------------------&quot;);</span><br><span class="line">        final HttpServletRequest request &#x3D; (HttpServletRequest) req;</span><br><span class="line">        HttpServletResponse response &#x3D; (HttpServletResponse) res;</span><br><span class="line">        &#x2F;&#x2F;POST的乱码解决方案</span><br><span class="line">        request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;返回数据的乱码解决方案</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentType(&quot;text&#x2F;html;charset&#x3D;utf-8&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用动态代理拦截,增强getParameter()后,放行</span><br><span class="line">        chain.doFilter((ServletRequest) Proxy.newProxyInstance(MyCharacterEncodingProxyFilter.class.getClassLoader(), request.getClass().getInterfaces(),</span><br><span class="line">                new InvocationHandler() &#123; &#x2F;&#x2F;直接实现接口</span><br><span class="line">                    @Override</span><br><span class="line">                    public Object invoke(Object proxy, Method method, Object[] args)</span><br><span class="line">                            throws Throwable &#123;</span><br><span class="line">                        &#x2F;&#x2F;如果请求方式是POST,则不用增强,直接调用目标对象的方法</span><br><span class="line">                        if (request.getMethod().equalsIgnoreCase(&quot;POST&quot;)) &#123;</span><br><span class="line">                            return method.invoke(request, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        String methodName &#x3D; method.getName();</span><br><span class="line">                        &#x2F;&#x2F;如果传递进来的方法不是getParameter(),则不用增强</span><br><span class="line">                        if (!methodName.equals(&quot;getParameter&quot;)) &#123;</span><br><span class="line">                            return method.invoke(request, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F;为GET,并且是getParameter(),...</span><br><span class="line">                        String value &#x3D; (String) method.invoke(request, args);</span><br><span class="line">                        if (value !&#x3D; null) &#123;</span><br><span class="line">                            value &#x3D; new String(value.getBytes(&quot;iso8859-1&quot;), &quot;utf-8&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        return value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;), response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;----------MyCharacterEncodingProxyFilter---destroy--------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void init(FilterConfig fConfig) throws ServletException &#123;</span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;----------MyCharacterEncodingProxyFilter---init--------------------&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其他配置方式与上面相同</p>
<p>引用自<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhangao0086/article/details/6240379">彻底解决全站乱码</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41092717/article/details/82755601">Filter使用全站解决中文乱码问题</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
    <article
  id="post-java-web/彻底搞定乱码-乱码产生的原因-1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/03/java-web/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9A%E4%B9%B1%E7%A0%81-%E4%B9%B1%E7%A0%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0-1/"
    >彻底搞定乱码-乱码产生的原因-1.md</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2020/06/03/java-web/%E5%BD%BB%E5%BA%95%E6%90%9E%E5%AE%9A%E4%B9%B1%E7%A0%81-%E4%B9%B1%E7%A0%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0-1/" class="article-date">
  <time datetime="2020-06-03T14:36:00.000Z" itemprop="datePublished">2020-06-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaWeb/">JavaWeb</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="1-什么是乱码？"><a href="#1-什么是乱码？" class="headerlink" title="1.什么是乱码？"></a>1.什么是乱码？</h1><blockquote>
<p>指的是由于本地计算机在用文本编辑器打开源文件时，使用了不相应字符集而造成部分或所有字符无法被阅读的一系列字符。</p>
</blockquote>
<h1 id="2-乱码产生的原因？"><a href="#2-乱码产生的原因？" class="headerlink" title="2.乱码产生的原因？"></a>2.乱码产生的原因？</h1><p>编码与解码方式不统一(编码方式有很多种)<br>文件在保存时是有编码格式的，只有当保存时使用的编码格式与读取时使用的编码格式相同时才能正确读取文件；例如UTF-8编码、GBK编码都可以读取中文，那么如果采用UTF-8编码保存文件，但是采用GBK编码读取文件就会造成乱码，因此UTF-8编码保存的文件应该使用UTF-8编码读取；</p>
<h1 id="3-编码方式介绍"><a href="#3-编码方式介绍" class="headerlink" title="3. 编码方式介绍"></a>3. 编码方式介绍</h1><p>说到编码方式，就不能不说，计算机的存储单位以及进制（现有的系统基本是基于二进制的，只能识别1和0。现在我们看到的网页、视频、图片、文字…..都是构建在其上的。）</p>
<p><strong>存储单位</strong><br>1 Byte （字节）= 8 Bits（位，信息量的最小单位）<br>1 KB = 1024 Bytes<br>1 MB = 1024 KB<br>1 GB = 1024 MB<br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%8D%95%E4%BD%8D/3943356?fr=aladdin">存储单位</a></p>
<p><strong>进制</strong><br>二进制<br>八进制<br>十进制<br>十六进制<br><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6/317457?fr=aladdin">进制</a></p>
<p><strong>字符编码介绍</strong></p>
<ul>
<li>ASCII：在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。<br><code>ASCII码</code><br><img src="https://upload-images.jianshu.io/upload_images/19382524-948452ca9fc59282.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ASCII码.jpg"></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/19382524-ef99877c30a7e1e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ASCII特殊字符解释.jpg"></p>
<ul>
<li><p>ISO-8859-1：又称Latin-1，计算机一开始只在美国使用，ASCII可以表示他们的符号，但是后来欧洲一些国家也开始使用计算机，很多国家使用的不是英文，ASCII的256个位置不够了，为了表示这些字符，就重新进行了编码，ISO-8859-1是单字节编码，向下兼容ASCII，其编码范围是0x00-0xFF，0x00-0x7F之间完全和ASCII一致，0x80-0x9F之间是控制字符，0xA0-0xFF之间是文字符号。此字符集主要支持欧洲使用的语言。</p>
</li>
<li><p>GB2312：后来计算机普及了，于是就中国要使用计算机了 但是机器不认得中文，于是就有了国际码, GB，是“国标”二字的汉语拼音首字母，1980年制定，由于“历史局限性”，此字符集内收录的字符很少，汉字总共收录了 6763 个，而且全部都是大陆通用的简体汉字。</p>
</li>
<li><p>BIG5：在GB2312肆虐横行的同时，我们的港澳台同胞，也制定了一个适用于当地繁体汉字需要的字符集，其对应编码名为 BIG5，也有人称之为大五码。</p>
</li>
<li><p>GBK：后来发现一些人名、文言文汉字、少数民族语言都需要支持，GB2312满足不了，就做了扩展，叫GBK标准,基本上采用了原来GB2312-80所有的汉字及码位，并涵盖了原Unicode中所有的汉字20902，总共收录了883个符号，21003个汉字及提供了1894个造字码位。</p>
</li>
<li><p>UNICODE：随着计算机的普及，编码也众多，需要统一，一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。</p>
<ul>
<li><p>UTF-8: 互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种unicode的实现方式。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一, 其他实现方式还包括UTF-16和UTF-32，不过在互联网上基本不用。<br>UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。<br>UTF-8的编码规则很简单，只有二条：</p>
<ul>
<li><p>a）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。</p>
</li>
<li><p>b）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ANSI: 不同的国家和地区制定了不同的标准，由此产生了 GB2312、GBK、GB18030、Big5、Shift_JIS 等各自的编码标准。这些使用多个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码。在简体中文Windows操作系统中，ANSI 编码代表 GBK 编码；在繁体中文Windows操作系统中，ANSI编码代表Big5；在日文Windows操作系统中，ANSI 编码代表 Shift_JIS 编码。</p>
</li>
</ul>
<p><code>编码对比</code><br><img src="https://upload-images.jianshu.io/upload_images/19382524-e297f70d2e088dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编码对比.png"></p>
<p><strong>发展</strong><br>ASCII（1字节）——&gt;ISO8859-1（1字节）——&gt;GB2312（2字节）——&gt;GBK（2字节）——&gt;unicode(utf-8(变长度编码),utf-16,utf-32)</p>
<p><img src="https://upload-images.jianshu.io/upload_images/19382524-6ce16085bb72df94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="编码方式.jpg"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaWeb/" rel="tag">JavaWeb</a></li></ul>

    </footer>
  </div>

    
 
   
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2020
        <i class="ri-heart-fill heart_icon"></i> d4c
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        由 <a href="https://hexo.io" target="_blank">Hexo</a> 强力驱动
        <span class="division">|</span>
        主题 - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="D4C的世界"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://www.jianshu.com/u/060a97a8dfe1">简书</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=357126&auto=0&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
  </div>
</body>

</html>